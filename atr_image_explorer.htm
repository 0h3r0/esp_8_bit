
<!DOCTYPE html>
<html>
<title>ATR</title>
<style>

body {
	background-color:#F8F8F8;
	font-family:"Open Sans","Helvetica Neue",Helvetica;
	padding: 20px;
    display: flex;
    flex-direction: column;
}
canvas {
    border:none;
    padding: 0px;
    margin:0px;
    transform-origin: 0px 2px;
}

nav {
    border: solid 1px #CCC;
    background: #CCF;
}
ul {
    list-style-type: none;
    border:none;
    margin: 0px;
    padding: 0px;
}
li {
    font-size: x-small;
}
li:hover {
    background-color: yellow;
    filter: brightness(200%);
}

h1, h2, h3, h4, h5, h6 {
	font-weight: 300;
}
h2 {
	font-size: 30px;
}
#gl {
	border: solid 1px #C00;
}
canvas {
  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
  image-rendering: -webkit-optimize-contrast; /* Safari                        */
  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
  image-rendering: pixelated;                 /* Awesome future-browsers       */
  image-rendering: crisp-edges;
  -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
}

td {
	border: solid 8px #F8F8F8;
	padding: 16px;
	margin: 16px;
	background: #23A;
	color: #FFF;
	font-weight: 500;
}
.sw {
	background: #A32;
}
.hw {
	background: #3A2;
}

.over {
  border: 2px dashed #F00;
}

.info {
    min-height: 32px;
    padding: 8px;
    border-bottom: 1px solid #CCC;
    font-size: small;
}
.infof {
    min-height: 32px;
    padding: 8px;
    border-bottom: 1px solid #CCC;
    font-size: small;
    overflow: hidden;
}

.close-icon
{
  display:block;
  box-sizing:border-box;
  width:12px;
  height:12px;
  border-width:2px;
  border-style: solid;
  border-color:gray;
  border-radius:100%;
  background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%,  white 56%,transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%,  white 56%,transparent 56%, transparent 100%);
  background-color:gray;
  transition: all 0.3s ease;
  margin: 4px;
  float:right;
}

.close-icon:hover {
    border-color:red;
    background-color:red;
}
.radio {
    cursor: pointer;
    font-size: small;
    height:16px;
    margin-left: 12px;
    margin-right: 12px;
    margin-top:4px;
}
.radio:last-child  {
    margin-right: 0px;
}
.radio span {
    border: 1px solid #CCC;
    padding-left: 12px;
    padding-right: 12px;
    vertical-align: top;
}
.hilite {
    background: #CCF;
}
.exts {
    font-weight: 300;
    padding: 4px;
    margin: 4px;
    font-size: small;
    width:336px;
}
.exts b {
    display: inline-block;
    margin-right: 16px;
    width : 100px;
    text-align:right;
}
.open {
    display: inline-block;
    font-size: large;
    cursor: pointer;
    width: 200px;
    border: solid 1px #CCC;
    font-weight: 300;
    margin: 20px;
    color: #AAA;
}
.open:hover {
    color: #888;
    border: solid 1px #888;
}
.open:active {
    color: #FFF;
    border: solid 1px #FFF;
}
.showcode {
    cursor: pointer;
    font-size: x-small;
    height:16px;
    padding: 2px 4px;
    margin-left: 12px;
    margin-right: 12px;
    margin-top:4px;
    border: solid 1px #CCC;
}
.showcode:hover {
    color: #F00;
    border: solid 1px #F00;
}

.palette {
    margin-left: 8px;
    display: inline-block;
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
    display: none;
    position: absolute;
    top:16px;
    background: #CCC;
    min-width: 288px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 100;
    margin: 0px;
    padding: 0px;
}

.dropdown:hover .dropdown-content {
  display: block;
}

.acolor {
    display: inline-block;
    min-width: 16px;
    min-height: 16px;
    border: solid 1px #CCC;
    vertical-align: bottom;
}
.acolor:hover {
    border: solid 1px #FFF;
}

</style>
<script>
var _ajax = function(m,u,c,d) {
	var x = new XMLHttpRequest;
	x.onreadystatechange=function(){x.readyState^4||c(this)};
	x.open(m,u);
	if (d) {
		x.setRequestHeader('Content-Type', 'application/json');
		d = JSON.stringify(d);
	}
	x.send(d);
};

var _q = function(q) {
	return document.querySelector(q)
};

var _h = function(q,html) {
    var e = _q(q);
    if (!e) {
        console.log("_h can't find " + q);
        return null;
    }
    return e.innerHTML = html;
};

var _txt = function(q) {
	return _q(q).innerText;
};

function stop()
{
	event.preventDefault();
	event.stopPropagation();
}

function get(url,cb,d)
{
	_ajax(d ? "post":"get",url,function(r) {
		var o = JSON.parse(r.responseText);
		cb(JSON.parse(r.responseText));
	},d);
}

function save_bytes(name, data)
{
    var blob = new Blob([data], {type: "application/data"});
    var link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = name;
    link.click();
};

var _hex = "0123456789ABCDEF";
function hex(i,len)
{
	var s = '';
	if (!len)
		len = 2;
	while(len--)
		s += _hex[(i >> (len*4)) & 0xF];
	return s;
}

function escapestr(c)
{
	switch (c) {
		case "<": return "&lt;"
		case ">": return "&gt;"
	}
	return c;
}

function esc(s)
{
	var n = '';
	for (var i = 0; i < s.length; i++)
		n+= escapestr(s.charAt(i));
	return n;
}

function hex_line(addr,data,i,len,awidth)
{
	var s = [hex(addr,awidth || 6) + "   "];
	var p = '';
    var pad = 16-len;
	while (len--) {
		var j = data[i];
		if (j >= 0x20 && j <= 0x7E)
			p += escapestr(String.fromCharCode(j));
		else
			p += '.'
		s.push(hex(data[i++],2) + " ");
	}
    while (pad--)
        p = "   " + p;
	return s.join('') + " " + p;
}

function hex_dump(a,i,len,awidth)
{
	var hex = [];
	for (var j = 0; j < len; j += 16)
		hex.push(hex_line(j,a,i+j,Math.min(16,len-j),awidth));
	return hex.join("\n");
}

//===================================================================================================
//===================================================================================================

var _fcanvas;
function draw(ctx,s,x,y,fcanvas)
{
    fcanvas = fcanvas || _fcanvas;
    for (var i = 0; i < s.length; i++) {
        var n = s.charCodeAt(i);
        ctx.drawImage(fcanvas,n*8,0,8,8,x*8,y*8,8,8);
        x++;
    }
}

// generate a canvas containing atari font
function get_font(src,palette)
{
    // map atascii to a line of font bits
    // https://www.atariarchives.org/mapping/appendix10.php
    function font_bits(c,y)
    {
        var invert = c & 0x80 ? 0xFF : 0x00;
        c = c & 0x7F;
        if (c >= 32 && c < 96)
            c -= 32;
        else if (c < 32)
            c += 64;
        return src[c*8 + y] ^ invert;
    }

    var canvas = document.createElement('canvas');
    canvas.width = 256*8;
    canvas.height = 8;
    var ctx = canvas.getContext('2d');

    var pix = ctx.getImageData(0,0,256*8,8);
    var d = pix.data;
    var f = 0;
    var i = 0;
    var ap = (p) => {
        p = atari_palette_rgb[palette[p]];
        d[i+0] = (p >> 16) & 0xFF;
        d[i+1] = (p >> 8) & 0xFF;
        d[i+2] = p & 0xFF;
        d[i+3] = 0xFF;
        i += 4;
    }
    for (var y = 0; y < 8; y++) {
    	for (var c = 0; c < 256; c++)
    	{
    		var b = font_bits(c,y);
            if (palette) {
                for (var x = 0; x < 4; x++) {
                    ap((b >> 6) & 3);
                    ap((b >> 6) & 3);
                    b <<= 2;
                }
            } else {
        		for (var x = 0; x < 8; x++) {
        			if (b & 0x80) {
              			d[i+0] = 128;
              			d[i+1] = 162;
              			d[i+2] = 255;
              		} else {
              			d[i+0] = 17;
              			d[i+1] = 59;
              			d[i+2] = 128;
              		}
              		d[i+3] = 0xFF;
              		i += 4;
              		b <<= 1;
        		}
            }
    	}
    }
    ctx.putImageData(pix,0,0);
    return canvas;
}

var atari_palette_rgb = [
    0x00000000,0x000F0F0F,0x001B1B1B,0x00272727,0x00333333,0x00414141,0x004F4F4F,0x005E5E5E,
    0x00686868,0x00787878,0x00898989,0x009A9A9A,0x00ABABAB,0x00BFBFBF,0x00D3D3D3,0x00EAEAEA,
    0x00001600,0x000F2100,0x001A2D00,0x00273900,0x00334500,0x00405300,0x004F6100,0x005D7000,
    0x00687A00,0x00778A17,0x00899B29,0x009AAC3B,0x00ABBD4C,0x00BED160,0x00D2E574,0x00E9FC8B,
    0x001C0000,0x00271300,0x00331F00,0x003F2B00,0x004B3700,0x00594500,0x00675300,0x00756100,
    0x00806C12,0x008F7C22,0x00A18D34,0x00B29E45,0x00C3AF56,0x00D6C36A,0x00EAD77E,0x00FFEE96,
    0x002F0000,0x003A0000,0x00460F00,0x00521C00,0x005E2800,0x006C3600,0x007A4416,0x00885224,
    0x00925D2F,0x00A26D3F,0x00B37E50,0x00C48F62,0x00D6A073,0x00E9B487,0x00FDC89B,0x00FFDFB2,
    0x00390000,0x00440000,0x0050000A,0x005C0F17,0x00681B23,0x00752931,0x0084373F,0x0092464E,
    0x009C5058,0x00AC6068,0x00BD7179,0x00CE838A,0x00DF949C,0x00F2A7AF,0x00FFBBC3,0x00FFD2DA,
    0x00370020,0x0043002C,0x004E0037,0x005A0044,0x00661350,0x0074215D,0x0082306C,0x00903E7A,
    0x009B4984,0x00AA5994,0x00BC6AA5,0x00CD7BB6,0x00DE8CC7,0x00F1A0DB,0x00FFB4EF,0x00FFCBFF,
    0x002B0047,0x00360052,0x0042005E,0x004E006A,0x005A1276,0x00672083,0x00762F92,0x00843DA0,
    0x008E48AA,0x009E58BA,0x00AF69CB,0x00C07ADC,0x00D18CED,0x00E59FFF,0x00F9B3FF,0x00FFCAFF,
    0x0016005F,0x0021006A,0x002D0076,0x00390C82,0x0045198D,0x0053279B,0x006135A9,0x006F44B7,
    0x007A4EC2,0x008A5ED1,0x009B6FE2,0x00AC81F3,0x00BD92FF,0x00D0A5FF,0x00E4B9FF,0x00FBD0FF,
    0x00000063,0x0000006F,0x00140C7A,0x00201886,0x002C2592,0x003A329F,0x004841AE,0x00574FBC,
    0x00615AC6,0x00716AD6,0x00827BE7,0x00948CF8,0x00A59DFF,0x00B8B1FF,0x00CCC5FF,0x00E3DCFF,
    0x00000054,0x00000F5F,0x00001B6A,0x00002776,0x00153382,0x00234190,0x0031509E,0x00405EAC,
    0x004A68B6,0x005A78C6,0x006B89D7,0x007D9BE8,0x008EACF9,0x00A1BFFF,0x00B5D3FF,0x00CCEAFF,
    0x00001332,0x00001E3E,0x00002A49,0x00003655,0x00004261,0x0012506F,0x00205E7D,0x002F6D8B,
    0x00397796,0x004987A6,0x005B98B7,0x006CA9C8,0x007DBAD9,0x0091CEEC,0x00A5E2FF,0x00BCF9FF,
    0x00001F00,0x00002A12,0x0000351E,0x0000422A,0x00004E36,0x000B5B44,0x00196A53,0x00287861,
    0x0033826B,0x0043927B,0x0054A38C,0x0065B49E,0x0077C6AF,0x008AD9C2,0x009EEDD6,0x00B5FFED,
    0x00002400,0x00003000,0x00003B00,0x00004700,0x0000530A,0x00106118,0x001E6F27,0x002D7E35,
    0x00378840,0x00479850,0x0059A961,0x006ABA72,0x007BCB84,0x008FDE97,0x00A3F2AB,0x00BAFFC2,
    0x00002300,0x00002F00,0x00003A00,0x00004600,0x00115200,0x001F6000,0x002E6E00,0x003C7C12,
    0x0047871C,0x0057972D,0x0068A83E,0x0079B94F,0x008ACA61,0x009EDD74,0x00B2F189,0x00C9FFA0,
    0x00001B00,0x00002700,0x000F3200,0x001C3E00,0x00284A00,0x00365800,0x00446600,0x00527500,
    0x005D7F00,0x006D8F19,0x007EA02B,0x008FB13D,0x00A0C24E,0x00B4D662,0x00C8EA76,0x00DFFF8D,
    0x00110E00,0x001D1A00,0x00292500,0x00353100,0x00413D00,0x004F4B00,0x005D5A00,0x006B6800,
    0x0076720B,0x0085821B,0x0097932D,0x00A8A43E,0x00B9B650,0x00CCC963,0x00E0DD77,0x00F7F48F,
];

// atari index color to canvas
// may stretch horizontally to maintain aspect ratio
function atari2canvas(canvas,atari,width,height,aspect,brightness)
{
    brightness = brightness || 1;
    canvas.width = width*aspect;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    var pix = ctx.getImageData(0,0,width*aspect,height);
    var d = pix.data;
    var src = 0;
    var i = 0;
    var pin = (p) => Math.min(0xFF,(p & 0xFF)*brightness);
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            var c = atari[src++];
            for (var j = 0; j < aspect; j++) {
                d[i+0] = pin(c >> 16);
                d[i+1] = pin(c >> 8);
                d[i+2] = pin(c);
                d[i+3] = 0xFF;
                i += 4;
            }
        }
    }
    ctx.putImageData(pix,0,0);
}

// convert a koala into a mic
function koala(src)
{
    var dst = new Uint8Array(7684);
    var dst_len = 7680;
    var i = src[4] + 1;
    var j = 0;
    var end = src.length;
    var type = src[7];

    if (type == 0) {
        while (i < end)
            dst[j++] = src[i++];  // no compression
    } else {
        while (i < end)
        {
            var b = src[i++];
            var len = b & 0x7F;
            if (len == 0) {
                len = src[i++] << 8;
                len |= src[i++];
            }
            b = (b & 0x80) ? -1 : src[i++];

            do {
                dst[j] = b < 0 ? src[i++] : b;
                if (j == (dst_len-1))
                    break;
                if (type == 2)
                    j++;
                else {
                    j += 80;
                    if (j >= dst_len)
                        j -= (j < dst_len + 40) ? dst_len - 40 : dst_len + 39;
                }
            } while (--len > 0);
        }
    }

    dst[7680] = src[17];
    dst[7681] = src[13];
    dst[7682] = src[14];
    dst[7683] = src[15];
    return dst;
}

// unpack from Piotr Fusik and Adrian Matoga

function unpack_rip(data,data_len,unpacked_data,unpacked_len)
{
    function create_fano_tree(src,offset,n,tree)
    {
        var i;
        var pos = 0;
        var positions = new Int32Array(16);
        for (i = 0; i < 16; i++)
            tree.count[i] = 0;
        for (i = 0; i < n; i++) {
            var bits = src[(i >> 1) + offset];
            bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
            tree.count[bits]++;
        }
        for (i = 0; i < 16; i++) {
            positions[i] = pos;
            pos += tree.count[i];
        }
        for (i = 0; i < n; i++) {
            var bits = src[(i >> 1) + offset];
            bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
            tree.values[positions[bits]++] = i & 0xFF;
        }
    }

    function get_bit(s)
    {
        var bits = s.bits;
        if (bits == 0x80) {
            if (s.offset >= s.length)
                return -1;
            bits = s.bytes[s.offset++] * 2 + 1;
        }
        else
            bits <<= 1;
        s.bits = bits & 0xFF;
        return bits >> 8;
    }

    function get_code(s,tree)
    {
        var p = tree.count[0];
        var i = 0;
        var bits;
        for (bits = 1; bits < 16; bits++) {
            var n = tree.count[bits];
            var bit = get_bit(s);
            if (bit == -1)
                return -1;
            i = i * 2 + bit;
            if (i < n)
                return tree.values[p + i];
            p += n;
            i -= n;
        }
        return -1;
    }

    var length_tree = {count:new Int32Array(16),values:new Uint8Array(256)};
    var distance_tree= {count:new Int32Array(16),values:new Uint8Array(256)};
    var literal_tree= {count:new Int32Array(16),values:new Uint8Array(256)};
    var stream = { bits:0x80, bytes:data, length:data_len, offset:16 + 288 };
    var unpacked_offset;

    /* "PCK" header (16 bytes) */
    if (data_len < 304 || data[0] != 80 || data[1] != 67 || data[2] != 75)  // PCK
        return 0;

    /* 288 bytes Shannon-Fano bit lengths */
    create_fano_tree(data,16, 64, length_tree);
    create_fano_tree(data,16 + 32, 256, distance_tree);
    create_fano_tree(data,16 + 32 + 128, 256, literal_tree);

    /* LZ77 */
    for (unpacked_offset = 0; unpacked_offset < unpacked_len; ) {
        switch (get_bit(stream)) {
        case -1:
            console.log(`rip truncation: got ${unpacked_offset} of ${unpacked_len}`);
            return 0;
        case 0:
            unpacked_data[unpacked_offset++] = get_code(stream,literal_tree);
            break;
        case 1:
            {
                var distance = get_code(stream, distance_tree) + 2;
                var len;
                if (distance > unpacked_offset)
                    return 0;
                len = get_code(stream, length_tree) + 2;
                do {
                    unpacked_data[unpacked_offset] = unpacked_data[unpacked_offset - distance];
                    unpacked_offset++;
                } while (--len > 0);
                break;
            }
        }
    }
    return 1;
}

function rip(d)
{
    var mode = d[7];
    var hdr_len = d[11] + (d[12] << 8);
    var height = d[15];
    var txt_len = d[17];
    var pal_len = d[20 + txt_len];
    var dst;
    var txt = '';

    for (var i = 0; i < txt_len; i++)
        txt += String.fromCharCode(d[24+i]);
    console.log(`rip mode:${mode}, rowbytes:${d[13]}, height:${d[15]} txt:${txt}`);

    if (d[9] == 0) {
        dst = d.slice(hdr_len,d.length);
    } else if (d[9] == 1) {
        var n = d[13];
        if (mode == 0x30)
            n += 4;  // 8 byte palette every 2nd line at end of image(s)
        n *= height;
        dst = new Uint8Array(n);
        var src = d.slice(hdr_len,d.length);
        if (!unpack_rip(src,src.length,dst,n))
            console.log("bad unpack_rip?");
    } else
        return null;

    // Copy palette
    var pal = new Uint8Array(pal_len);
    for (var i = 0; i < pal_len; i++)
        pal[i] = d[24 + txt_len + i];

    // separate mutlirip palette
    var multihip_pal = null;
    if (mode == 0x30) {
        var n = d[13]*height;
        multihip_pal = dst.slice(n,dst.length);
        dst = dst.slice(0,n);
    }
    // have the unpacked frame
    return {
        pal:pal,
        multihip_pal:multihip_pal,
        data:dst,
        ext:"rip_hip",
        mode:mode
    }
}

var _palette = [0,5,10,15];
var _reload_palette = 1;
var _palettable = ["gr7","gr8","gr10","mic","mcp","inp","cin","pic","scr"];
function is_palettable(ext)
{
    return _palettable.indexOf(ext) != -1;
}

function render_image(canvas,f)
{
    var pal0 = _reload_palette ? [0,5,10,15] : _palette.slice();
    var pal1 = _reload_palette ? [0,5,10,15] : _palette.slice();
    var hip =  [0,0,2,4,6,8,10,12,14, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0];
    var multihip_pal = null;

    var data = f.data;
    var ext = f.ext;
    var height = 192;
    var width = 160;
    var offset = 40;
    var offset2 = 40;
    var gr = 7;
    var src = 0;

    // Turn PIC into MIC
    if (ext == "pic") {
        data = koala(data);
        ext = "mic";
    }

    // Turn RIP into something
    if (ext == "rip")
    {
        var r = rip(data);
        data = r.data;
        ext = r.ext;
        hip = r.pal;

        switch (r.mode) {
            case 14: ext = "rip_mode_14"; break;
            case 16: ext = "rip_mode_16"; break;
            case 30:
                ext = "inp";
                for (var i = 0; i < 4; i++)
                    pal0[i] = pal1[i] = hip[4 + ((i-1)&3)];
                break;
            case 48:
                ext = "rip_multirip";
                multihip_pal = r.multihip_pal;
                break;
        }
    }

    function set_pal(p,offset,len)
    {
        if (_reload_palette) {
            pal0.length = len;
            pal1.length = len;
            for (var i = 0; i < len; i++)
                pal0[i] = pal1[i] = p[offset++];
            _palette = pal0.slice();
            redraw_palette();
        }
    }

    function avg(p0,p1)
    {
        return ((atari_palette_rgb[p0] & 0x00FEFEFE) + (atari_palette_rgb[p1] & 0x00FEFEFE)) >> 1;
    }

    // Atari Graphics Works?
    if (ext == "scr" && data.length == 16000)
    {
        data = data.slice(0,7684);
        ext = "gr7";
    }

    switch (data.length)
    {
        case 3844:
        case 7684:
        case 9604:
        case 16004: // Interpainter
            set_pal(data,data.length-4,4);
            break;

        case 7682:
            set_pal(data,data.length-2,2);
            break;

        case 7689:
            set_pal(data,data.length-9,9);
            break;
    }

    switch (ext) {
        case "mic":
        case "gr7":
            height = 96;
            if (data.length >= 7680)
                height = 192;
            break;

        case "gr8":
            width = 320;
            gr = 8;
            if (data.length == 7680)
                set_pal([0,0xF],0,2);
            break;

        case "gr9":
            width = 80;
            gr = 9;
            break;

        case "g10":
            width = 80;
            gr = 10;
            break;

        case "ilc":
        case "pzm":
            width = 80;
            offset = 40*192;
            gr = 33;
            break;

        case "plm":
        case "apc":
            width = 80;
            height = 96;
            gr = 32;
            break;

        case "mcp":
            height = data.length == 16008 ? 200:100;
            for (var i = 0; i < 4; i++) {
                pal0[i] = data[height*80+((i-1)&3)];
                pal1[i] = data[height*80+4+((i-1)&3)];
            }
            offset = height*40;
            gr = 39;
            break;

        case "inp":
            height = 200;
            offset = height*40;
            gr = 37;
            break;

        // switch between Graphics 11 and Graphics 15
        // https://en.wikipedia-on-ipfs.org/wiki/Atari_8-bit_family_software-driven_graphics_modes.html
        case "cin":
            offset = 80*height/2;
            gr = 34;
            break;

        case "raw":
            src += 4;       // skip header 'XLPB'
            for (var i = 0; i < 4; i++) {
                pal0[i] = data[0x3C04 + ((i-1)&3)];
                pal1[i] = data[0x3C08 + ((i-1)&3)];
            }
            height = 192;
            gr = 37;
            break;

        case "ist":
            height = 200;
            src = 16;
            offset = 0x2000;
            gr = 35;
            break;

        case "hip":
            // 10 and 9 greyscale
            gr = 36;
            var hdr = le16(data,0); // FFFF
            if (hdr == 0xFFFF && data.length != 16009) {    // Has header: Frames have explicit length
                var len0 = le16(data,4)-le16(data,2)+1;
                var len1 = le16(data,4+len0+6)-le16(data,2+len0+6)+1;
                src += 6;
                offset = len0 + 6;
                height = len0/40;
            } else {
                height = data.length/80 | 0;
                src = height*40;
                offset = -height*40;
                var p = height*80;
                if ((p + 9) == data.length) {   // has a palette?
                    for (var i = 0; i < 9; i++)
                        hip[i] = data[p++];
                }
            }
            break;

        case "tip":
            width = data[5];
            height = data[6];
            var frame_len = data[7] | (data[8] << 8);
            // 3 frames: gr9 luma, gr10 luma, gr11 chroma
            src += 9;                   // gr9 luma
            offset = frame_len;         // gr10 luma
            offset2 = frame_len*2;      // chroma
            gr = 38;
            break;

        case "rip_hip":
        case "rip_multirip":
            height = data.length/80;
            offset = height*40;
            gr = 36;
            break;

        case "rip_mode_14":
            height = 192;
            for (var i = 0; i < 4; i++) {
                pal0[i] = pal1[i] = hip[4+(i == 0 ? 4:i-1)] & 0xFE;
                set_pal(pal0,0,4);
            }
            gr = 7;
            break;

        case "rip_mode_16":
            for (var i = 0; i < 4; i++) {
                pal0[i] = hip[4 + i]; // TODO: why are they all dark?
                pal1[i] = hip[0 + i] & 0xFE;
            }
            height = data.length/80;
            offset = data.length/2;
            gr = 37;    //
            break;
    }

    var buf = new Uint32Array(width*height);
    var dst = 0;
    var lastp = 0;
    var ap = atari_palette_rgb;
    for (var y = 0; y < height; y++) {
        var pal = (y & 1) ? pal1 : pal0;

        if (gr == 35) { // ist palette
            pal0[0] = pal1[0]= data[0x4000 + y];
            pal0[1] = pal1[1]= data[0x40C8 + y];
            pal0[2] = pal1[2]= data[0x4190 + y];
            pal0[3] = pal1[3]= data[0x4258 + y];
        }

        if (multihip_pal)
        {
            for (var i = 0; i < 16; i++) {
                var gr10_to_reg = [0,1,2,3,4,5,6,7,8,8,8,8,4,5,6,7];
                hip[i] = i == 0 ? 0 : multihip_pal[gr10_to_reg[i] + ((y>>1)<<3) - 1] & 0xFE;
            }
        }

        for (var x = 0; x < width;) {
            var b = data[src];
            switch (gr) {
                case 7:
                    for (var j = 0; j < 4; j++) {
                        var bb = (b >> 6) & 3;
                        buf[dst++] = ap[pal[bb]];
                        b <<= 2;
                    }
                    x += 4;
                    break;

                case 8:
                    for (var j = 0; j < 8; j++) {
                        var bb = (b >> 7) & 1;
                        buf[dst++] = ap[pal[bb]];
                        b <<= 1;
                    }
                    x += 8;
                    break;

                case 9:
                    buf[dst++] = ap[b >> 4];        // 9=16 greys,10=index,11=chroma
                    buf[dst++] = ap[b & 0x0F];
                    x += 2;
                    break;

                case 10:
                    buf[dst++] = ap[pal[b >> 4]];
                    buf[dst++] = ap[pal[b & 0x0F]];
                    x += 2;
                    break;

                case 32:
                    var luma = data[src+offset];
                    buf[dst++] = ap[((luma >> 4) & 0x0F) | (b & 0xF0)];
                    buf[dst++] = ap[(luma & 0xF) | ((b & 0xF) << 4)];
                    x += 2;
                    break;

                case 33:
                    var hue = data[src+offset];
                    buf[dst++] = ap[((b >> 4) & 0x0F) | (hue & 0xF0)];
                    buf[dst++] = ap[(b & 0xF) | ((hue & 0xF) << 4)];
                    x += 2;
                    break;

                case 34: // Champions
                    var hue = data[src+offset];
                    buf[dst++] = ap[pal[b >> 6] | (hue & 0xF0)];
                    buf[dst++] = ap[pal[(b >> 4) & 3] | (hue & 0xF0)];
                    buf[dst++] = ap[pal[(b >> 2) & 3] | ((hue & 0xF) << 4)];
                    buf[dst++] = ap[pal[b & 3] | ((hue & 0xF) << 4)];
                    x += 4;
                    break;

                case 36:  // hip
                    //  00001111
                    //  LL222233
                    var p2 = hip[b >> 4];         // gr10
                    var p3 = hip[b & 0xF];
                    b = data[src+offset];
                    var p0 = b >> 4;                // gr9
                    var p1 = b & 0xF;

                    buf[dst++] = avg(p0,lastp);
                    buf[dst++] = avg(p0,p2);
                    buf[dst++] = avg(p1,p2);
                    buf[dst++] = avg(p1,p3);
                    lastp = p3;
                    x += 4;
                    break;// hip

                case 35: // ist
                case 37: // rip_mode_16/inp
                    var b2 = data[src+offset];
                    var pal_0 = (y & 1) ? pal1 : pal0;
                    var pal_1 = (y & 1) ? pal0 : pal1;
                    for (var j = 0; j < 4; j++) {
                        var p0 = pal_1[(b2 >> 6) & 3];
                        var p1 = pal_0[(b >> 6) & 3];
                        buf[dst++] = avg(p0,p1);
                        b <<= 2;
                        b2 <<= 2;
                    }
                    x += 4;
                    break;

                case 39: // mcp
                    var b2 = data[src+offset];
                    for (var j = 0; j < 4; j++) {
                        var p0 = pal0[(b >> 6) & 3];
                        var p1 = pal1[(b2 >> 6) & 3];
                        buf[dst++] = avg(p0,p1);
                        b <<= 2;
                        b2 <<= 2;
                    }
                    x += 4;
                    break;

                case 38: // tip!
                    var luma = data[src];
                    var luma10 = data[src+offset];
                    var chroma = data[src+offset2];          // chroma

                    var l0 = ((luma >> 4) + lastp) >> 1;
                    var l1 = ((luma >> 4) + hip[luma10 >> 4]) >> 1;
                    var l2 = ((luma & 0xF) + hip[luma10 >> 4]) >> 1;
                    lastp = hip[luma10 & 0xF];
                    var l3 = ((luma & 0xF) + lastp) >> 1;

                    var c0 = chroma & 0xF0;
                    var c1 = (chroma << 4) & 0xF0;

                    buf[dst++] = ap[c0|l0];
                    buf[dst++] = ap[c0|l1];
                    buf[dst++] = ap[c1|l2];        // 9=16 greys,10=index,11=chroma
                    buf[dst++] = ap[c1|l3];
                    x += 4;
                    break;            
            }
            src++;
        }
        if (gr == 32 && offset == 40)
            src += 40;
    }

    var brightness = 1;
    switch (ext) {
        case "rip_mode_16": brightness = 3; break;    // rip_mode_16,raw is dark, boost it please
        case "raw":
        case "mcp":
            brightness = 2;
            break;
    }
    atari2canvas(canvas,buf,width,height,320/width,brightness);
    return [320/canvas.width*2,192/canvas.height*2];
}

// make an atari line of text to look like dir
function draw_line(id,txt)
{
    var c = _q(id);
    c.width = txt.length*8;
    c.height = 8;
    var ctx = c.getContext('2d');
    draw(ctx,txt,0,0);
    resize_parent(c,2);
}

// Simple radio and check buttons
var _radios = {};
var _checks = {};
function radio_init(name,values,value)
{
    var cur = _radios[name] ? _radios[name].value : 0;
    value = value || cur;
    var s = '';
    for (var i = 0; i < values.length; i++)
        s += `<span onclick="radio_click('${name}',${i})" ${i == value ? "class='hilite'" : ""}>${values[i]}</span>`;
    _radios[name] = {values:values,value:value};
    return s;
}

function radio_click(name,n)
{
    var v = _radios[name];
    if (n != -1 && n != v.value) {
        v.value = n;
        radio_changed(name,n);
    }
}

function radio_changed(name,v)
{
    switch (name) {
        case "layout":refresh(); break;
    }
}

function check_init(name,dname)
{
    _checks[name] = _checks[name] || 0;
    var cur = _checks[name] ? _checks[name] : 0;
    return `<span onclick="check_click('${name}')" ${cur ? "class='hilite'" : ""}>${dname}</span>`;
}

function check_click(name,n)
{
    _checks[name] ^= 1;
    check_changed(name,_checks[name]);
}

function check_changed(name,v)
{
    switch (name) {
        case "indent":
        case "multicolor":
            refresh();
            break;
    }
}

function resize_parent(e,sx,sy)
{
    sy = sy || sx;
    e.style.transform = `scale(${sx},${sy})`;
    e.parentNode.style.width = e.width*sx + "px";
    e.parentNode.style.height = e.height*sy + "px";
}

function show_ataritext(f,lst,font,palette)
{
    render_file(f);

    var fcanvas;
    if (font)
        fcanvas = get_font(font,palette);

    var layout = _radios["layout"].value;
    var cols = layout < 2 ? 40:80;
    var margin = layout == 0 ? 2 : 0;
    var wrap = [];

    if (layout == 3) {  // Don't wrap at all
        lst.forEach(line => cols = Math.max(line.length,cols));
        cols += 2*margin;
        wrap = lst;
    } else {
        var wrap = [];
        lst.forEach(s => {
            while (s.length > (cols-margin))
            {
                wrap.push(s.substr(0,(cols-margin)));
                s = s.substr((cols-margin));
            }
            wrap.push(s);
        });
    }

    var c = _q("#show");
    c.width = cols*8;
    c.height = wrap.length*8+16;
    var ctx = c.getContext('2d');
    ctx.webkitImageSmoothingEnabled = false;
    var bg = atari_palette_rgb[palette ? palette[0] : 128+20];
    ctx.fillStyle = '#'+hex(bg,6); // "rgba(17,59,128,1)";
    ctx.fillRect(0, 0, c.width, c.height);
    for (var y = 0; y < wrap.length; y++)
        draw(ctx,wrap[y],margin,y+1,fcanvas);
    resize_parent(c,layout == 3 ? 1:2);
}

var _font = [
    // atari 128 rom font
    // 32..95
    // 0..31
    // 96..128
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x00,
    0x00,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
    0x00,0x66,0xff,0x66,0x66,0xff,0x66,0x00,
    0x18,0x3e,0x60,0x3c,0x06,0x7c,0x18,0x00,
    0x00,0x66,0x6c,0x18,0x30,0x66,0x46,0x00,
    0x1c,0x36,0x1c,0x38,0x6f,0x66,0x3b,0x00,
    0x00,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x0e,0x1c,0x18,0x18,0x1c,0x0e,0x00,
    0x00,0x70,0x38,0x18,0x18,0x38,0x70,0x00,
    0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,
    0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,
    0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,
    0x00,0x06,0x0c,0x18,0x30,0x60,0x40,0x00,
    0x00,0x3c,0x66,0x6e,0x76,0x66,0x3c,0x00,
    0x00,0x18,0x38,0x18,0x18,0x18,0x7e,0x00,
    0x00,0x3c,0x66,0x0c,0x18,0x30,0x7e,0x00,
    0x00,0x7e,0x0c,0x18,0x0c,0x66,0x3c,0x00,
    0x00,0x0c,0x1c,0x3c,0x6c,0x7e,0x0c,0x00,
    0x00,0x7e,0x60,0x7c,0x06,0x66,0x3c,0x00,
    0x00,0x3c,0x60,0x7c,0x66,0x66,0x3c,0x00,
    0x00,0x7e,0x06,0x0c,0x18,0x30,0x30,0x00,
    0x00,0x3c,0x66,0x3c,0x66,0x66,0x3c,0x00,
    0x00,0x3c,0x66,0x3e,0x06,0x0c,0x38,0x00,
    0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x00,
    0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x30,
    0x06,0x0c,0x18,0x30,0x18,0x0c,0x06,0x00,
    0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,
    0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00,
    0x00,0x3c,0x66,0x0c,0x18,0x00,0x18,0x00,
    0x00,0x3c,0x66,0x6e,0x6e,0x60,0x3e,0x00,
    0x00,0x18,0x3c,0x66,0x66,0x7e,0x66,0x00,
    0x00,0x7c,0x66,0x7c,0x66,0x66,0x7c,0x00,
    0x00,0x3c,0x66,0x60,0x60,0x66,0x3c,0x00,
    0x00,0x78,0x6c,0x66,0x66,0x6c,0x78,0x00,
    0x00,0x7e,0x60,0x7c,0x60,0x60,0x7e,0x00,
    0x00,0x7e,0x60,0x7c,0x60,0x60,0x60,0x00,
    0x00,0x3e,0x60,0x60,0x6e,0x66,0x3e,0x00,
    0x00,0x66,0x66,0x7e,0x66,0x66,0x66,0x00,
    0x00,0x7e,0x18,0x18,0x18,0x18,0x7e,0x00,
    0x00,0x06,0x06,0x06,0x06,0x66,0x3c,0x00,
    0x00,0x66,0x6c,0x78,0x78,0x6c,0x66,0x00,
    0x00,0x60,0x60,0x60,0x60,0x60,0x7e,0x00,
    0x00,0x63,0x77,0x7f,0x6b,0x63,0x63,0x00,
    0x00,0x66,0x76,0x7e,0x7e,0x6e,0x66,0x00,
    0x00,0x3c,0x66,0x66,0x66,0x66,0x3c,0x00,
    0x00,0x7c,0x66,0x66,0x7c,0x60,0x60,0x00,
    0x00,0x3c,0x66,0x66,0x66,0x6c,0x36,0x00,
    0x00,0x7c,0x66,0x66,0x7c,0x6c,0x66,0x00,
    0x00,0x3c,0x60,0x3c,0x06,0x06,0x3c,0x00,
    0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x00,
    0x00,0x66,0x66,0x66,0x66,0x66,0x7e,0x00,
    0x00,0x66,0x66,0x66,0x66,0x3c,0x18,0x00,
    0x00,0x63,0x63,0x6b,0x7f,0x77,0x63,0x00,
    0x00,0x66,0x66,0x3c,0x3c,0x66,0x66,0x00,
    0x00,0x66,0x66,0x3c,0x18,0x18,0x18,0x00,
    0x00,0x7e,0x0c,0x18,0x30,0x60,0x7e,0x00,
    0x00,0x1e,0x18,0x18,0x18,0x18,0x1e,0x00,
    0x00,0x40,0x60,0x30,0x18,0x0c,0x06,0x00,
    0x00,0x78,0x18,0x18,0x18,0x18,0x78,0x00,
    0x00,0x08,0x1c,0x36,0x63,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,
    0x00,0x36,0x7f,0x7f,0x3e,0x1c,0x08,0x00,
    0x18,0x18,0x18,0x1f,0x1f,0x18,0x18,0x18,
    0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,
    0x18,0x18,0x18,0xf8,0xf8,0x00,0x00,0x00,
    0x18,0x18,0x18,0xf8,0xf8,0x18,0x18,0x18,
    0x00,0x00,0x00,0xf8,0xf8,0x18,0x18,0x18,
    0x03,0x07,0x0e,0x1c,0x38,0x70,0xe0,0xc0,
    0xc0,0xe0,0x70,0x38,0x1c,0x0e,0x07,0x03,
    0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f,0xff,
    0x00,0x00,0x00,0x00,0x0f,0x0f,0x0f,0x0f,
    0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff,
    0x0f,0x0f,0x0f,0x0f,0x00,0x00,0x00,0x00,
    0xf0,0xf0,0xf0,0xf0,0x00,0x00,0x00,0x00,
    0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
    0x00,0x00,0x00,0x00,0xf0,0xf0,0xf0,0xf0,
    0x00,0x1c,0x1c,0x77,0x77,0x08,0x1c,0x00,
    0x00,0x00,0x00,0x1f,0x1f,0x18,0x18,0x18,
    0x00,0x00,0x00,0xff,0xff,0x00,0x00,0x00,
    0x18,0x18,0x18,0xff,0xff,0x18,0x18,0x18,
    0x00,0x00,0x3c,0x7e,0x7e,0x7e,0x3c,0x00,
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
    0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
    0x00,0x00,0x00,0xff,0xff,0x18,0x18,0x18,
    0x18,0x18,0x18,0xff,0xff,0x00,0x00,0x00,
    0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
    0x18,0x18,0x18,0x1f,0x1f,0x00,0x00,0x00,
    0x78,0x60,0x78,0x60,0x7e,0x18,0x1e,0x00,
    0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x00,
    0x00,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,
    0x00,0x18,0x30,0x7e,0x30,0x18,0x00,0x00,
    0x00,0x18,0x0c,0x7e,0x0c,0x18,0x00,0x00,
    0x00,0x18,0x3c,0x7e,0x7e,0x3c,0x18,0x00,
    0x00,0x00,0x3c,0x06,0x3e,0x66,0x3e,0x00,
    0x00,0x60,0x60,0x7c,0x66,0x66,0x7c,0x00,
    0x00,0x00,0x3c,0x60,0x60,0x60,0x3c,0x00,
    0x00,0x06,0x06,0x3e,0x66,0x66,0x3e,0x00,
    0x00,0x00,0x3c,0x66,0x7e,0x60,0x3c,0x00,
    0x00,0x0e,0x18,0x3e,0x18,0x18,0x18,0x00,
    0x00,0x00,0x3e,0x66,0x66,0x3e,0x06,0x7c,
    0x00,0x60,0x60,0x7c,0x66,0x66,0x66,0x00,
    0x00,0x18,0x00,0x38,0x18,0x18,0x3c,0x00,
    0x00,0x06,0x00,0x06,0x06,0x06,0x06,0x3c,
    0x00,0x60,0x60,0x6c,0x78,0x6c,0x66,0x00,
    0x00,0x38,0x18,0x18,0x18,0x18,0x3c,0x00,
    0x00,0x00,0x66,0x7f,0x7f,0x6b,0x63,0x00,
    0x00,0x00,0x7c,0x66,0x66,0x66,0x66,0x00,
    0x00,0x00,0x3c,0x66,0x66,0x66,0x3c,0x00,
    0x00,0x00,0x7c,0x66,0x66,0x7c,0x60,0x60,
    0x00,0x00,0x3e,0x66,0x66,0x3e,0x06,0x06,
    0x00,0x00,0x7c,0x66,0x60,0x60,0x60,0x00,
    0x00,0x00,0x3e,0x60,0x3c,0x06,0x7c,0x00,
    0x00,0x18,0x7e,0x18,0x18,0x18,0x0e,0x00,
    0x00,0x00,0x66,0x66,0x66,0x66,0x3e,0x00,
    0x00,0x00,0x66,0x66,0x66,0x3c,0x18,0x00,
    0x00,0x00,0x63,0x6b,0x7f,0x3e,0x36,0x00,
    0x00,0x00,0x66,0x3c,0x18,0x3c,0x66,0x00,
    0x00,0x00,0x66,0x66,0x66,0x3e,0x0c,0x78,
    0x00,0x00,0x7e,0x0c,0x18,0x30,0x7e,0x00,
    0x00,0x18,0x3c,0x7e,0x7e,0x18,0x3c,0x00,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x00,0x7e,0x78,0x7c,0x6e,0x66,0x06,0x00,
    0x08,0x18,0x38,0x78,0x38,0x18,0x08,0x00,
    0x10,0x18,0x1c,0x1e,0x1c,0x18,0x10,0x00,
];

function makefont()
{
	
}

//===================================================================================================
//===================================================================================================
//  Drag and drop

function drop_init(el,onfile,all_done)
{
    function over(b)
    {
        var c = _q("#toc").classList;
        if (b)
            c.add("over");
        else
            c.remove("over");
    }

    function handleFiles(files)
    {
        function readAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const fr = new FileReader();
                fr.onerror = reject;
                fr.onload = function(evt) {
                    onfile(file,evt.target.result);
                    resolve(fr.result);
                }
                fr.readAsArrayBuffer(file);
            });
        }

        // Load all the files, callback when done
        Promise.all(Array.prototype.map.call(files,readAsArrayBuffer))
        .then(urls => {
            all_done();
        })
        .catch(error => {
            console.log(error);
        });
    }

    function handleFileSelect(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        over(0);
        handleFiles(evt.dataTransfer.files);
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }
    el.addEventListener('dragover', handleDragOver, false);
    el.addEventListener('drop', handleFileSelect, false);
    el.addEventListener('dragenter', e => over(1), false);
    el.addEventListener('dragleave', e => over(0), false);

    _q("#fe").addEventListener("change", e => handleFiles(_q("#fe").files), false);
}

//===================================================================================================
//===================================================================================================
// http://www.atarimax.com/jindroush.atari.org/afmtbas.html
// Disassemble m65

var _mac65_table1 = [
    "ERROR -", ".IF",     ".ELSE",   ".ENDIF",  ".MACRO",  ".ENDM",   ".TITLE",  "",        
    ".PAGE",   ".WORD",   ".ERROR",  ".BYTE",   ".SBYTE",  ".DBYTE",  ".END",    ".OPT",    
    ".TAB",    ".INCLUDE",".DS",     ".ORG",    ".EQU",    "BRA",     "TRB",     "TSB",     
    ".FLOAT",  ".CBYTE",  ";",       ".LOCAL",  ".SET",    "*=",      "=",       ".=",      
    "JSR",     "JMP",     "DEC",     "INC",     "LDX",     "LDY",     "STX",     "STY",     
    "CPX",     "CPY",     "BIT",     "BRK",     "CLC",     "CLD",     "CLI",     "CLV",     
    "DEX",     "DEY",     "INX",     "INY",     "NOP",     "PHA",     "PHP",     "PLA",     
    "PLP",     "RTI",     "RTS",     "SEC",     "SED",     "SEI",     "TAX",     "TAY",     
    "TSX",     "TXA",     "TXS",     "TYA",     "BCC",     "BCS",     "BEQ",     "BMI",     
    "BNE",     "BPL",     "BVC",     "BVS",     "ORA",     "AND",     "EOR",     "ADC",     
    "STA",     "LDA",     "CMP",     "SBC",     "ASL",     "ROL",     "LSR",     "ROR",     
    "",        "STZ",     "DEA",     "INA",     "PHX",     "PHY",     "PLX",     "PLY",     
];

var _mac65_table2 = [
    null,    null,    null,    null,    null,    "",      "",      "",      
    "",      null,    "",      "%$",    "%",    "*",     null,    null,    
    null,    null,    "+",     "-",     "*",     "/",     "&",     null,    
    "=",     "<=",    ">=",    "<>",    ">",     "<",     "-",     "[",     
    "]",     null,    null,    null,    "!",     "^",     null,    "\\",     
    null,    null,    null,    null,    null,    null,    null,    ".REF",  
    ".DEF",  ".NOT",  ".AND",  ".OR",   "<",     ">",     ",X)",   "),Y",   
    ",Y",    ",X",    ")",     "",      null,    ",",     "#",     "A",     
    "(",     '"',     null,    null,    null,    "NO",    "OBJ",   "ERR",   
    "EJECT", "LIST",  "XREF",  "MLIST", "CLIST", "NUM",   null,    null,    
];

function mac65(a,i,len)
{
    if (le16(a,i) != 0xFEFE)
        return null;
    if (le16(a,i+2) != (len-4))
        return null;
    var end = i + len;
    i += 4;

    var indent = 5;
    var asm = [];
    while (i < len) {
        var line_number = le16(a,i);
        var line_end = i + a[i+2];
        i += 3;

        var s = line_number + ' ';
        var pad = (''+line_number).length + indent;
        var c = a[i++];
        if (c & 0x80) {
            c -= 0x80;  // label
            while (c--)
                s += String.fromCharCode(a[i++]);
            if (i == line_end)
            {
                asm.push(s);
                continue;
            }
            c = a[i++];
        } else if (c == 0 || c == 88) {
            while (i < line_end)
                s += String.fromCharCode(a[i++]);   // raw
            asm.push(s);
            continue;
        } else if (c == 1) {
            indent++;           // IF
        } else if (c == 3) {
            indent--;           // ENDIF
        }

        if (c >= 96)
            return null;
        while (s.length < pad)
            s += ' ';
        if (s[s.length-1] != ' ')
            s += ' ';
        s += _mac65_table1[c] + ' ';   // token

        while (i < line_end) {
            c = a[i++];
            switch (c) {
                case 5: s += '$'+hex(le16(a,i),4); i += 2;      break;
                case 6: s += '$'+hex(a[i++]);                   break;
                case 7: s += le16(a,i); i += 2;                 break;
                case 8: s += a[i++];                            break;
                case 10: s += "'"+String.fromCharCode(a[i++]);  break;
                case 59:
                    s += ' ';
                    while (i < line_end)
                        s += String.fromCharCode(a[i++]);   // comment
                    break;
                default:
                    if (c & 0x80) {
                        c -= 0x80;
                        while (c--)
                            s += String.fromCharCode(a[i++]);
                    } else {
                        var t = _mac65_table2[c];
                        if (!t)
                            return null;
                        s += t;
                        if (c > 64)
                            s += ' ';   // not sure all of all the padding rules
                    }
                    break;
            }
        }
        asm.push(s);
    }
    return asm;
}

//===================================================================================================
//===================================================================================================
// http://www.atarimax.com/jindroush.atari.org/afmtbas.html
// Disassemble atari basic

var _basic_commands = [
    // 56 in classic Basic
	"REM","DATA","INPUT","COLOR","LIST","ENTER","LET","IF","FOR","NEXT","GOTO",
	"GO TO","GOSUB","TRAP","BYE","CONT","COM","CLOSE","CLR","DEG","DIM","END",
	"NEW","OPEN","LOAD","SAVE","STATUS","NOTE","POINT","XIO","ON","POKE","PRINT",
	"RAD","READ","RESTORE","RETURN","RUN","STOP","POP","?","GET","PUT","GRAPHICS",
	"PLOT","POSITION","DOS","DRAWTO","SETCOLOR","LOCATE","SOUND","LPRINT","CSAVE",
	"CLOAD","LET_","ERROR",

    // Turbo Basic
    "DPOKE ","MOVE ","-MOVE ","*F" ,"REPEAT ","UNTIL ","WHILE ","WEND ",
    "ELSE ","ENDIF ","BPUT ","BGET ","FILLTO ","DO ","LOOP ","EXIT ",
    "DIR ","LOCK ","UNLOCK ","RENAME ","DELETE ","PAUSE ","TIME$= ","PROC ",
    "EXEC ","ENDPROC ","FCOLOR ","*L ",
    "------------------------------",
    "RENUM ","DEL ","DUMP ",
    "TRACE ","TEXT ","BLOAD ","BRUN ","GO# ","# ", "*B ","PAINT ",
    "CLS ","DSOUND ","CIRCLE ","%PUT ","%GET "
];

var _basic_operators = [
	"_0","_1","_2","_3","_4","_5","_6","_7","_8","_9","_A","_B","_C","_D",
	"NCONST","SCONST","NOUSE","NOUSE",",","$",":",";","EOL"," GOTO "," GOSUB "," TO ",
	" STEP "," THEN ","#","<=","<>",">=","<",">","=","^","*","+","-","/"," NOT "," OR "," AND ",
	"(",")","=","=","<=","<>",">=","<",">","=","+","-","(","(","(","(","(",",",
	"STR$","CHR$","USR","ASC","VAL","LEN","ADR","ATN","COS","PEEK","SIN","RND","FRE",
	"EXP","LOG","CLOG","SQR","SGN","ABS","INT","PADDLE","STICK","PTRIG","STRIG",

    // Turbo Basic
    "DPEEK","&","!","INSTR","INKEY$"," EXOR ","HEX$","DEC",
    " DIV ","FRAC","TIME$","TIME"," MOD ","EXEC ","RND","RAND",
    "TRUNC","%0","%1","%2","%3","GO# ","UINSTR","ERR","ERL"
];

function ataribasic(a,i,len)
{
    var indenting = _checks['indent'];
	var b = {
		lomem: le16(a,i+0),   // should be zero
		vnt: le16(a,i+2),     // start of variable name table
		vnte: le16(a,i+4),    // end of variable name table
		vvt: le16(a,i+6),     // start of variable values table
		stmtab: le16(a,i+8),  // start of token area
		stmcur: le16(a,i+10), // current line (line 32768)
		starp: le16(a,i+12),  // end of token area, start of stacks

		variable_names:[],
		variable_values:[],
		statements:[]
	}

    function failed(reason)
    {
        reason = reason || "Bytes don't look like Basic";
        console.log(reason);
        console.log(b);
        console.log(listing);
        return null;
    }

	var origin = b.vnt - b.lomem - 14; // file offsets are weird?
    if (origin < 0)
        return failed();
	b.vnt -= origin;
	b.vnte -= origin;
	b.vvt -= origin;
	b.stmtab -= origin;
	b.stmcur -= origin;
	b.starp -= origin;
    if (b.vnt > b.vnte || b.vnte > b.vvt || b.vvt > b.stmtab || b.stmtab > b.stmcur || b.stmcur > b.starp)
        return failed();    // Not a basic file?

	function get_string(data,si,len) {
		var s = '';
		while (len--) {
            var c = String.fromCharCode(data[si++]);
			s += c;
            if (c == '"')
                s += c;
        }
		return s;
	}

	function bcd(data,bi)
	{
		var n = 0;
		var e = data[bi++];
		if (e == 0)
			return 0;
		for (var j = 0; j < 5; j++) {
			var c = data[bi++];
			n *= 10;
			n += c >> 4;
			n *= 10;
			n += c & 0xF;
		}
		e = (e - 68) * 2;

		switch (e) {	// Math.pow was not producing integers
			case -1: return n/10;
			case -2: return n/100;
			case -3: return n/1000;
			case -4: return n/10000;
		}
		return n*Math.pow(10,e);
	}

	var vnt_begin = i + b.vnt;
	var vnt_end = i + b.vnte;
	var n = '';
    var nmap = {};
    var ncount = 0;
	for (var j = vnt_begin; j < vnt_end; j++) {
		n += String.fromCharCode(a[j]&0x7F);
		if (a[j] & 0x80)
		{
			if (n.length && n[n.length-1] == '(')
				n = n.substr(0,n.length-1);	// 
            nmap[n] = 1;
            ncount++;
			b.variable_names.push(n);
			n = '';
		}
	}

    if (Object.keys(nmap).length == 1 && ncount > 1)
    {
        console.log("resetting variable names");
        b.variable_names = [];  // name table was set to the same value: reset it
    }

	var vvt_begin = i + b.vvt;	// NOT SURE WHY THESE ARE +1
	var tokens_begin = i + b.stmtab;
    var vid = 0;
	for (var j = vvt_begin; j < tokens_begin; j += 8) {
        var v = {name:b.variable_names[a[j+1]]};

        if (!v.name) {  // someone got rid of all the variable names. make new ones
            var ch = String.fromCharCode(65+(vid % 26));    // 'A'
            var n = Math.floor(vid++/26);
            if (n)
                ch += n+1;                              // A,B,C ... A2,B2...
            switch (a[j]) {
                case 0x80:
                case 0x81:
                    ch += '$';
                    break;
            }
            b.variable_names[a[j+1]] = v.name = ch;     // make up a name if missing
        }

		var p0 = le16(a,j+2);
		var p1 = le16(a,j+4);
		var p2 = le16(a,j+6);
		switch (a[j]) {
			case 0x00:
				v.type = "scalar";
				v.value = bcd(a,j+2);
				break;
			case 0x40:
			case 0x41:
				v.type = "array";
				break;
			case 0x80:
			case 0x81:
				v.type = "string";
				v.value = get_string(a,b.starp+i+p0,p1);
				break;
			default:
				v.type = a[j];
		}
		b.variable_values.push(v);
	}

    //var tokens_end = i+b.stmcur;
    var tokens_end = i+b.starp; // kings cribbage see https://www.atariarchives.org/mapping/memorymap.php STMCUR
    var turbo = false;

	var listing = [];
    var indent = 0;
	for (var j = tokens_begin; j < tokens_end;) {
		var s = {tok:[]};
		s.lineno = le16(a,j);
		var len = a[j+2];

        if (s.lineno == 32768 || len == 0)
            break; // stmcur

		var line = s.lineno + " ";

        if (indent) {
			var cmd = a[j+4];
            // Check if indent needs to decreased *before* the first command:
            //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF     ELSE
            if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41 || cmd == 0x40)
                line = line + " ".repeat(2 * indent - 2);
            else
                line = line + " ".repeat(2 * indent);
        }

		// Parse statements
		var k = 3;
        var op;
		while (k < len) {
			var end = a[j+k];
			var cmd = a[j+k+1];
			k += 2;
            if (cmd >= 56) {
                turbo = true;
                if (cmd >= 101)
                    return failed("Unrecognized command index:" + cmd);    // not basic
            }

			s.tok.push(_basic_commands[cmd]);
			if (cmd != 0x36) {	// slient LET
			    line += _basic_commands[cmd];
                if (line[line.length-1] != ' ')
                    line += ' ';
            }

			if (cmd < 2) {	// REM,DATA
				var txt = '';
				while (k < end) {
                    var c = a[j+k++];
                    if (c == 0x9B)
                        break;
					txt += String.fromCharCode(c);
                }
				s.tok.push(txt);
				line += txt;
				k = end;
			}

            // Check indent:
            //         FOR            REPEAT         WHILE          DO             PROC
            if (cmd == 0x08 || cmd == 0x3C || cmd == 0x3E || cmd == 0x45 || cmd == 0x4F)
                indent += indenting;
            //              IF
            else if (cmd == 0x07) {
                // Verify if there is THEN
                var got_then = false;
                for(var l=k; l<end; l++)
                {
                    var op = a[j+l];
                    if( op == 0x1B ) {
                        got_then = true;
                        break;
                    }
                    else if( !op )
                        l++;
                    else if( op == 0x0F )
                        l+=a[j+l+1] + 1;
                    else if( op == 0x0E || op == 0x0D )
                        l+=6;
                }
                if (!got_then)
                    indent += indenting;
            }
            //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF
            else if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41)
                indent = indent > 0 ? indent - 1 : 0;

			while (k < end) {
				op = a[j+k++];
				switch (op) {
					case 0x0F: // SCONST
						var txt = '';
						var blen = a[j+k++];
						while (blen--) {
							c = a[j+k++];
							if (c == 0x9B)
								break;
							txt += String.fromCharCode(c);
						}
						s.tok.push(txt);
						line += '"' + txt + '"';
						break;
                    case 0x0D: // BCD hex const
                        var n = bcd(a,j+k);
                        var c = 1;
                        while (n >= (1 << c*8))
                            c++;
                        s.tok.push(n);
                        k += 6;
                        line += '$' + hex(n,c*2);
                        break;
					case 0x0E: // NCONST
						var n = bcd(a,j+k);
						s.tok.push(n);
						k += 6;
						line += n;
						break;
					case 0x16: // EOL
						k = end;
						break;
					default: {
                        var txt;
						if (op & 0x80)
							txt = b.variable_names[op&0x7F];
                        else if (!op) {
                            turbo = true;
                            txt = b.variable_names[a[j+k++] ^ 0x80];    // thx dragonstomper
                        } else {
                            if (op >= 85) {
                                turbo = true;
                                if (op >= 110)
                                    return failed("Unrecognized operation:" + op);    // not basic
                            }
							txt = _basic_operators[op];
                        }
                        if (txt == ":" || txt[0] == ' ')
                            line = line.trim();
						line += txt;
						s.tok.push(txt);
					}
				}
			}
		}
		b.statements.push(s);
		listing.push(line);
		j += len;
	}

    var d = [];
    listing.forEach(line => {
        for (var i = 0; i < line.length; i++)
            d.push(line.charCodeAt(i));
        d.push(0x9B);
    });
	return {listing:listing,tokens:b,lst:new Uint8Array(d)}
}

//===================================================================================================
//===================================================================================================
// Atari syms

var _syms_zp = {
'00':["LINZBS","LINBUG STORAGE"],
'01':["NGFLAG",""],
'02':["CASINI","CASSETTE INIT LOC"],
'03':["CASINI+1",""],
'04':["RAMLO","RAM POINTER FOR MEM TEST"],
'05':["RAMLO+1",""],
'06':["TRAMSZ","TEMP LOC FOR RAM SIZE"],
'07':["TSTDAT","RAM TEST DATA LOC"],
'08':["WARMST","WARM START FLAG"],
'09':["BOOTQ","SUCCESSFUL BOOT FLAG"],
'0A':["DOSVEC","DOS START VECTOR"],
'0B':["DOSVEC+1",""],
'0C':["DOSINI","DOS INIT ADDRESS"],
'0D':["DOSINI+1",""],
'0E':["APPMHI","APPLICATION MEM HI LIMIT"],
'0F':["APPMHI+1",""],
'10':["POKMSK","SYSTEM MASK FOR POKEY IRQ ENABLE"],
'11':["BRKKEY","BREAK KEY FLAG"],
'12':["RTCLOK","REAL TIME CLOCK (60HZ OR 16.66666 MS)"],
'13':["RTCLOK+1",""],
'14':["RTCLOK+2",""],
'15':["BUFADR","INDIRECT BUFFER ADDRESS REG"],
'16':["BUFADR+1",""],
'17':["ICCOMT","COMMAND FOR VECTOR HANDLER"],
'18':["DSKFMS","DISK FILE MANAGER POINTER"],
'19':["DSKFMS+1",""],
'1A':["DSKUTL","DISK UTILITIES POINTER"],
'1B':["DSKUTL+1",""],
'1C':["PTIMOT","PRINTER TIME OUT REGISTER"],
'1D':["PBPNT","PRINT BUFFER POINTER"],
'1E':["PBUFSZ","PRINT BUFFER SIZE"],
'1F':["PTEMP","TEMP REG"],
'20':["ICHIDZ","HANDLER INDEX NUMBER ($FF := IOCB FREE)"],
'21':["ICDNOZ","DEVICE NUMBER (DRIVE NUMBER)"],
'22':["ICCOMZ","COMMAND CODE"],
'23':["ICSTAZ","STATUS OF LAST IOCB ACTION"],
'24':["ICBALZ","BUFFER ADDRESS (LOW)"],
'25':["ICBAHZ","BUFFER ADDRESS (HIGH)"],
'26':["ICPTLZ","PUT BYTE ROUTINE ADDRESS - 1"],
'27':["ICPTHZ",""],
'28':["ICBLLZ","BUFFER LENGTH (LOW)"],
'29':["ICBLHZ","BUFFER LENGTH (HIGH)"],
'2A':["ICAX1Z","AUX INFO"],
'2B':["ICAX2Z",""],
'2C':["ICSPRZ","SPARE BYTES (CIO LOCAL USE)"],
'2D':["ICSPRZ+1",""],
'2E':["ICIDNO","IOCB LUMBER * 16"],
'2F':["CIOCHR","CHARACTER BYTE FOR CURRENT OPERATION"],
'30':["STATUS","INTERNAL STATUS STORAGE"],
'31':["CHKSUM","CHECKSUM (SINGLE BYTE SUM WITH CARRY)"],
'32':["BUNRLO","POINTER TO DATA BUFFER (LO BYTE)"],
'33':["BUFRHI","POINTER TO DATA BUFFER (HI BYTE)"],
'34':["BFENLO","NEXT BYTE PAST END OF BUFFER (LO BYTE)"],
'35':["BNENHI","NEXT BYTE PAST END OF BUFFER (HI BYTE)"],
'36':["CRETRY","NUMBER OF COMMAND FRAM RETRIES"],
'37':["DRETRY","NUMBER OF DEVICE RETRIES"],
'38':["BUFRFL","DATA BUFFER FULL FLAG"],
'39':["RECVDN","RECEIVE DONE FLAG"],
'3A':["XMTDON","XMIT DONE FLAG"],
'3B':["CHKSNT","CHECKSUM SENT FLAG"],
'3C':["NOCKSM","NO CHECKSUM FOLLOWS DATA FLAG"],
'3D':["BPTR","BUFFER POINTER (CASSETTE)"],
'3E':["FTYPE","FILE TYPE (SHORT IRG/LONG IRG)"],
'3F':["FEOF","END OF FILE FLAG (CASSETTE)"],
'40':["FREQ","FREQ COUNTER FOR CONSOLE SPEAKER"],
'41':["SOUNDR","NOISY I/O FLAG. (ZERO IS QUIET)"],
'42':["CRITIC","CRITICAL CODE IF NON-ZERO)"],
'43':["FMSZPG","DISK FILE MANAGER SYSTEM STORAGE (7 BYTES)"],
'44':["FMSZPG+1",""],
'45':["FMSZPG+2",""],
'46':["FMSZPG+3",""],
'47':["FMSZPG+4",""],
'48':["FMSZPG+5",""],
'49':["FMSZPG+6",""],
'4A':["CKEY","SET WHEN GAME START PRESSED"],
'4B':["CASSBT","CASSETTE BOOT FLAG"],
'4C':["DSTAT","DISPLAY STATUS"],
'4D':["ATRACT","ATTRACT MODE FLAG"],
'4E':["DRKMSK","DARK ATTRACT MASK"],
'4F':["COLRSH","ATTRACT COLOR SHIFTER (XORED WITH PLAYFIELD)"],
'50':["TMPCHR","TEMP CHAR STORAGE (DISPLAY HANDLER)"],
'51':["HOLD1","TEMP STG (DISPLAY HANDLER)"],
'52':["LMARGN","LEFT MARGIN"],
'53':["RMARGN","RIGHT MARGIN"],
'54':["ROWCRS","CURSOR COUNTERS"],
'55':["COLCRS",""],
'56':["COLCRS+1",""],
'57':["DINDEX","DISPLAY INDEX (VARIOUS QUANTS)"],
'58':["SAVMSC",""],
'59':["SAVMSC+1",""],
'5A':["OLDROW","PREVIOUS ROW/COL"],
'5B':["OLDCOL",""],
'5C':["OLDCOL+1",""],
'5D':["OLDCHR","DATA UNDER CURSOR"],
'5E':["OLDADR",""],
'5F':["OLDADR+1",""],
'60':["NEWROW","POINT DRAWS TO HERE"],
'61':["NEWCOL",""],
'62':["PALNTS",""],
'63':["LOGCOL","POINTS AT COLUMN IN LOGICAL LINE"],
'64':["ADRESS","INDIRECT POINTER"],
'65':["ADRESS+1",""],
'66':["MLTTMP","MULTIPLY TEMP"],
'67':["TOADR+1",""],
'68':["SAVADR",""],
'69':["SAVADR+1",""],
'6A':["RAMTOP","RAM SIZE DEFINED BY POWER ON LOGIC"],
'6B':["BUFCNT","BUFFER COUNT"],
'6C':["BUFSTR","EDITOR GETCH POINTER"],
'6D':["BUFSTR+1",""],
'6E':["BITMSK","BIT MASK"],
'6F':["SHFAMT","OUTCHR SHIFT"],
'70':["ROWAC","USED BY \"DRAW\""],
'71':["ROWAC+1",""],
'72':["COLAC",""],
'73':["COLAC+1",""],
'74':["ENDPT",""],
'75':["ENDPT+1",""],
'76':["DELTAR",""],
'77':["DELTAC",""],
'78':["DELTAC+1",""],
'79':["ROWINC",""],
'7A':["COLINC",""],
'7B':["SWPFLG","NON-0 IF TXT AND RAM SWAPPED"],
'7C':["HOLDCH","CH BEFORE CNTL & SHFT PROCESSING IN KGETCH"],
'7D':["INSDAT","INSERT CHAR SAVE"],
'7E':["COUNTR","DRAW COUNTER"],
'7F':["COUNTR+1",""],
'80':["LOMEM","BASIC POINTER TO LOW MEMORY"],
'81':["LOMEM+1",""],
'82':["VNTP","BASIC VARIABLE NAME TABLE"],
'83':["VNTP+1",""],
'84':["VNTD","BASIC VARIABLE NAME TABLE END"],
'85':["VNTD+1",""],
'86':["VVTP","BASIC VARIABLE VALUE TABLE"],
'87':["VVTP+1",""],
'88':["STMTAB","BASIC STATEMENT TABLE"],
'89':["STMTAB+1",""],
'8A':["STMCUR","BASIC CURRENT STATEMENT POINTER"],
'8B':["STMCUR+1",""],
'8C':["STARP","BASIC STRING AND ARRAY POINTER"],
'8D':["STARP+1",""],
'8E':["RUNSTK","BASIC RUNTIME STACK"],
'8F':["RUNSTK+1",""],
'90':["MEMTOP","BASIC TOP OF MEMORY"],
'91':["MEMTOP+1",""],
'92':["MEOLFLG",""],
'94':["COX",""],
'95':["POKADR",""],
'96':["POKADR+1",""],
'97':["SVESA",""],
'98':["SVESA+1",""],
'99':["MVFA",""],
'9A':["MVFA+1",""],
'9B':["MVTA",""],
'9C':["MVTA+1",""],
'9D':["CPC",""],
'9E':["CPC+1",""],
'9F':["LLNGTH",""],
'A0':["TSLNUM",""],
'A1':["TSLNUM+1",""],
'A2':["MVLNG",""],
'A3':["MVLNG+1",""],
'A4':["ECSIZE",""],
'A5':["ECSIZE+1",""],
'A6':["DIRFLG",""],
'A7':["STMLBD",""],
'A8':["STINDEX",""],
'A9':["OPSTKX",""],
'AA':["ARSTKX",""],
'AB':["EXSVOP",""],
'AC':["EXSVPR",""],
'AD':["LELNUM",""],
'AE':["LELNUM+1",""],
'AF':["STENUM",""],
'B0':["COMCNT",""],
'B1':["ADFLAG",""],
'B2':["SVDISP",""],
'B3':["ONLOOP",""],
'B4':["ENTDTD",""],
'B5':["LISTDTD",""],
'B6':["DATAD",""],
'B7':["DATALN",""],
'B8':["DATALN+1",""],
'B9':["ERRNUM",""],
'BA':["STOPLN",""],
'BB':["STOPLN+1",""],
'BC':["TRAPLN",""],
'BD':["TRAPLN+1",""],
'BE':["SAVCUR",""],
'BF':["SAVCUR+1",""],
'C0':["IOCMD",""],
'C1':["IODVC",""],
'C2':["PROMPT",""],
'C3':["ERRSAV",""],
'C4':["TEMPA",""],
'C5':["TEMPA+1",""],
'C6':["ZTEMP2",""],
'C7':["ZTEMP2+1",""],
'C8':["COLOR",""],
'C9':["PTABW",""],
'CA':["LOADFLG",""],
'D2':["VTYPE",""],
'D3':["VNUM",""],
'D4':["FR0",""],
'D5':["FR0+1",""],
'D6':["FR0+2",""],
'D7':["FR0+3",""],
'D8':["FR0+4",""],
'D9':["FR0+5",""],
'DA':["FRE",""],
'DB':["FRE+1",""],
'DC':["FRE+2",""],
'DD':["FRE+3",""],
'DE':["FRE+4",""],
'DF':["FRE+5",""],
'E0':["FR1",""],
'E1':["FR1+1",""],
'E2':["FR1+2",""],
'E3':["FR1+3",""],
'E4':["FR1+4",""],
'E5':["FR1+5",""],
'E6':["FR2",""],
'E7':["FR2+1",""],
'E8':["FR2+2",""],
'E9':["FR2+3",""],
'EA':["FR2+4",""],
'EB':["FR2+5",""],
'EC':["FRX",""],
'ED':["EEXP",""],
'EE':["NSIGN",""],
'EF':["ESIGN",""],
'F0':["FCHRFLG",""],
'F1':["DIGRT",""],
'F2':["CIX",""],
'F3':["INBUFF",""],
'F4':["INBUFF+1",""],
'F5':["ZTEMP1",""],
'F6':["ZTEMP1+1",""],
'F7':["ZTEMP4",""],
'F8':["ZTEMP4+1",""],
'F9':["ZTEMP3",""],
'FA':["ZTEMP3+1",""],
'FB':["RADFLG",""],
'FC':["FLPTR",""],
'FD':["FLPTR+1",""],
'FE':["FPTR2",""],
'FF':["FPTR2+1",""]
}

var _syms_ = {
'0200':["VDSLST","DISPLAY LIST NMI VECTOR"],
'0201':["VDSLST+1",""],
'0202':["VPRCED","PROCEED LINE IRQ VECTOR"],
'0203':["VPRCED+1",""],
'0204':["VINTER","INTERRUPT LINE IRQ VECTOR"],
'0205':["VINTER+1",""],
'0206':["VBREAK","\"BRK\" VECTOR"],
'0207':["VBREAK+1",""],
'0208':["VKEYBD","POKEY KEYBOARD IRQ VECTOR"],
'0209':["VKEYBD+1",""],
'020A':["VSERIN","POKEY SERIAL INPUT READY"],
'020B':["VSERIN+1",""],
'020C':["VSEROR","POKEY SERIAL OUTPUT READY"],
'020D':["VSEROR+1",""],
'020E':["VSEROC","POKEY SERIAL OUTPUT DONE"],
'020F':["VSEROC+1",""],
'0210':["VTIMR1","POKEY TIMER 1 IRQ"],
'0211':["VTIMR1+1",""],
'0212':["VTIMR2","POKEY TIMER 2 IRQ"],
'0213':["VTIMR2+1",""],
'0214':["VTIMR4","POKEY TIMER 4 IRQ (DO NOT USE)"],
'0215':["VTIMR4+1",""],
'0216':["VIMIRQ","IMMEDIATE IRQ VECTOR"],
'0217':["VIMIRQ+1",""],
'0218':["CDTMV1","COUNT DOWN TIMER 1"],
'0219':["CDTMV1+1",""],
'021A':["CDTMV1","COUNT DOWN TIMER 2"],
'021B':["CDTMV2+1",""],
'021C':["CDTMV1","COUNT DOWN TIMER 3"],
'021D':["CDTMV3+1",""],
'021E':["CDTMV1","COUNT DOWN TIMER 4"],
'021F':["CDTMV4+1",""],
'0220':["CDTMV1","COUNT DOWN TIMER 5"],
'0221':["CDTMV5+1",""],
'0222':["VVBLKI","IMMEDIATE VERTICAL BLANK NMI VECTOR"],
'0223':["VVBLKI+1",""],
'0224':["VVBLKD","DEFERRED VERTICAL BLANK NMI VECTOR"],
'0225':["VVBLKD+1",""],
'0226':["CDTMA1","COUNT DOWN TIMER 1 JSR ADDRESS"],
'0227':["CDTMA1+1",""],
'0228':["CDTMA2","COUNT DOWN TIMER 2 JSR ADDRESS"],
'0229':["CDTMA2+1",""],
'022A':["CDTMF3","COUNT DOWN TIMER 3 FLAG"],
'022B':["SRTIMR","SOFTWARE REPEAT TIMER"],
'022C':["CDTMF4","COUNT DOWN TIMER 4 FLAG"],
'022D':["INTEMP","IANS TEMP (???)"],
'022E':["CDTMF5","COUNT DOWN TIMER 5 FLAG"],
'022F':["SDMCTL","SAVE DMACTL REGISTER"],
'0230':["SDLSTL","SAVE DISPLAY LIST (LOW)"],
'0231':["SDLSTH","SAVE DISPLAY LIST (HIGH)"],
'0232':["SSKCTL","SKCTL REGISTER RAM"],
'0233':["LCOUNT",""],
'0234':["LPENH","LIGHT PEN HORIZ VALUE"],
'0235':["LPENV","LIGHT PEN VERT VALUE"],
'0236':["BRKKY",""],
'0237':["BRKKY+1",""],
'0238':["VPIRQ",""],
'0239':["VPIRQ+1",""],
'023A':["CDEVIC","COMMAND FRAME BUFFER - DEVICE"],
'023B':["CCOMND","COMMAND"],
'023C':["CAUX1","COMMAND AUX BYTE 1"],
'023D':["CAUX2","COMMAND AUX BYTE 2"],
'023E':["TEMP",""],
'023F':["ERRFLG","ERROR FLAG - ANY DEVICE ERROR EXCEPT TIMEOUT"],
'0240':["DFLAGS","DISK FLAGS FROM SECTOR ONE"],
'0241':["DBSECT","NUMBER OF DISK BOOT SECTORS"],
'0242':["BOOTAD","ADDRESS FOR DISK BOOT LOADER"],
'0243':["BOOTAD+1",""],
'0244':["COLDST","COLDSTART FLAG (1 = DOING COLDSTART)"],
'0245':["RECLEN",""],
'0246':["DSKTIM","DISK TIME OUT REG"],
'0247':["LINBUF","CHAR LINE BUFFER (40 BYTES)"],
'0248':["SHPDVS",""],
'0249':["PDIMSK",""],
'024A':["RELADR",""],
'024B':["RELADR+1",""],
'024C':["PPTMPA",""],
'024D':["PPTMPX",""],
'026B':["CHSALT",""],
'026C':["VSFLAG",""],
'026D':["KEYDIS",""],
'026E':["FINE",""],
'026F':["GPRIOR","GLOBAL PRIORITY CELL"],
'0270':["PADDL0","POT 0 SHADOW"],
'0271':["PADDL1","POT 1 SHADOW"],
'0272':["PADDL2","POT 2 SHADOW"],
'0273':["PADDL3","POT 3 SHADOW"],
'0274':["PADDL4","POT 4 SHADOW"],
'0275':["PADDL5","POT 5 SHADOW"],
'0276':["PADDL6","POT 6 SHADOW"],
'0277':["PADDL7","POT 7 SHADOW"],
'0278':["STICK0","JOYSTICK 0 SHADOW"],
'0279':["STICK1","JOYSTICK 1 SHADOW"],
'027A':["STICK2","JOYSTICK 2 SHADOW"],
'027B':["STICK3","JOYSTICK 3 SHADOW"],
'027C':["PTRIG0","PADDLE 0 TRIGGER"],
'027D':["PTRIG1","PADDLE 1 TRIGGER"],
'027E':["PTRIG2","PADDLE 2 TRIGGER"],
'027F':["PTRIG3","PADDLE 3 TRIGGER"],
'0280':["PTRIG4","PADDLE 4 TRIGGER"],
'0281':["PTRIG5","PADDLE 5 TRIGGER"],
'0282':["PTRIG6","PADDLE 6 TRIGGER"],
'0283':["PTRIG7","PADDLE 7 TRIGGER"],
'0284':["STRIG0","JOYSTICK 0 TRIGGER"],
'0285':["STRIG1","JOYSTICK 1 TRIGGER"],
'0286':["STRIG2","JOYSTICK 2 TRIGGER"],
'0287':["STRIG3","JOYSTICK 3 TRIGGER"],
'0288':["CSTAT","(UNUSED)"],
'0289':["WMODE","R/W FLAG FOR CASSETTE"],
'028A':["BLIM","BUFFER LIMIT (CASSETTE)"],
'028B':["IMASK",""],
'028C':["JVECK",""],
'028D':["JVECK+1",""],
'028E':["NEWADR",""],
'028F':["NEWADR+1",""],
'0290':["TXTROW","TEXT ROWCRS"],
'0291':["TXTCOL","TEXT ROWCOL"],
'0292':["TXTCOL+1",""],
'0293':["TINDEX","TEXT INDEX"],
'0294':["TXTMSC","FOOLS CONVRT INTO NEW MSC"],
'0295':["TXTMSC+1",""],
'0296':["TXTOLD","OLDROW AND OLDCOL FOR TEXT (AND THEN SOME)"],
'0297':["TXTOLD+1",""],
'0298':["TXTOLD+2",""],
'0299':["TXTOLD+3",""],
'029A':["TXTOLD+4",""],
'029B':["TXTOLD+5",""],
'029C':["TMPX1",""],
'029D':["HOLD3",""],
'029E':["SUBTMP",""],
'029F':["HOLD2",""],
'02A0':["DMASK",""],
'02A1':["TMPLBT",""],
'02A2':["ESCFLG","ESCAPE FLAG"],
'02A3':["TABMAP","TAB BUFFER"],
'02A4':["TABMAP+1",""],
'02A5':["TABMAP+2",""],
'02A6':["TABMAP+3",""],
'02A7':["TABMAP+4",""],
'02A8':["TABMAP+5",""],
'02A9':["TABMAP+6",""],
'02AA':["TABMAP+7",""],
'02AB':["TABMAP+8",""],
'02AC':["TABMAP+9",""],
'02AD':["TABMAP+A",""],
'02AE':["TABMAP+B",""],
'02AF':["TABMAP+C",""],
'02B0':["TABMAP+D",""],
'02B1':["TABMAP+E",""],
'02B2':["LOGMAP","LOGICAL LINE START BIT MAP"],
'02B3':["LOGMAP+1",""],
'02B4':["LOGMAP+2",""],
'02B5':["LOGMAP+3",""],
'02B6':["INVFLG","INVERSE VIDEO FLAG (ATARI KEY)"],
'02B7':["FILFLG","RIGHT FILL FLAG FOR DRAW"],
'02B8':["TMPROW",""],
'02B9':["TMPCOL",""],
'02BA':["TMPCOL+1",""],
'02BB':["SCRFLG","SET IF SCROLL OCCURS"],
'02BC':["HOLD4","MORE DRAW TEMPS"],
'02BD':["HOLD5",""],
'02BE':["SHFLOK","SHIFT LOCK KEY"],
'02BF':["BOTSCR","BOTTOM OF SCREEN (24 NORM, 4 SPLIT)"],
'02C0':["PCOLR0","P0 COLOR"],
'02C1':["PCOLR1","P1 COLOR"],
'02C2':["PCOLR2","P2 COLOR"],
'02C3':["PCOLR3","P3 COLOR"],
'02C4':["COLOR0","COLOR 0"],
'02C5':["COLOR1",""],
'02C6':["COLOR2",""],
'02C7':["COLOR3",""],
'02C8':["COLOR4","BACKGROUND"],
'02C9':["RUNADR",""],
'02CA':["RUNADR+1",""],
'02CB':["HIUSED",""],
'02CC':["HIUSED+1",""],
'02CD':["ZHIUSE",""],
'02CE':["ZHIUSE+1",""],
'02CF':["GBYTEA",""],
'02D0':["GBYTEA+1",""],
'02D1':["LOADAD",""],
'02D2':["LOADAD+1",""],
'02D3':["ZLOADA",""],
'02D4':["ZLOADA+1",""],
'02D5':["DSCTLN",""],
'02D6':["DSCTLN+1",""],
'02D7':["ACMISR",""],
'02D8':["ACMISR+1",""],
'02D9':["KRPDEL",""],
'02DA':["KEYREP",""],
'02DB':["NOCLIK",""],
'02DC':["HELPFG",""],
'02DD':["DMASAV",""],
'02DE':["PBPNT",""],
'02DF':["PBUFSZ",""],
'02E0':["RUNAD","DOS RUN ADDRESS"],
'02E1':["RUNAD+1",""],
'02E2':["INITAD","DOS INIT ADDRESS"],
'02E3':["INITAD+1",""],
'02E4':["RAMSIZ","RAM SIZE (HI BYTE ONLY)"],
'02E5':["MEMTOP","TOP OF AVAILABLE MEMORY"],
'02E6':["MEMTOP+1",""],
'02E7':["MEMLO","BOTTOM OF AVAILABLE MEMORY"],
'02E8':["MEMLO+1",""],
'02E9':["HNDLOD",""],
'02EA':["DVSTAT","STATUS BUFFER"],
'02EB':["DVSTAT+1",""],
'02EC':["DVSTAT+2",""],
'02ED':["DVSTAT+3",""],
'02EE':["CBAUDL","CASSETTE BAUD RATE (LO BYTE)"],
'02EF':["CBAUDH","CASSETTE BAUD RATE (HI BYTE)"],
'02F0':["CRSINH","CURSOR INHIBIT (00 = CURSOR ON)"],
'02F1':["KEYDEL","KEY DELAY"],
'02F2':["CH1",""],
'02F3':["CHACT","CHACTL REGISTER (SHADOW)"],
'02F4':["CHBAS","CHBAS REGISTER (SHADOW)"],
'02F5':["NEWROW",""],
'02F6':["NEWCOL",""],
'02F7':["NEWCOL+1",""],
'02F8':["ROWINC",""],
'02F9':["COLINC",""],
'02FA':["CHAR",""],
'02FB':["ATACHR","ATASCII CHARACTER"],
'02FC':["CH","GLOBAL VARIABLE FOR KEYBOARD"],
'02FD':["FILDAT","RIGHT FILL DATA (DRAW)"],
'02FE':["DSPFLG","DISPLAY FLAG: DISP CONTROLS IF NON-ZERO"],
'02FF':["SSFLAG","START/STOP FLAG (CNTL-1) FOR PAGING"],
'0300':["DDEVIC","BUS I.D. NUMBER"],
'0301':["DUNIT","UNIT NUMBER"],
'0302':["DCOMND","BUS COMMAND"],
'0303':["DSTATS","COMMAND TYPE/STATUS RETURN"],
'0304':["DBUFLO","DATA BUFFER POINTER"],
'0305':["DBUFHI","..."],
'0306':["DTIMLO","DEVICE TIME OUT IN 1 SEC. UNITS"],
'0307':["DUNUSE","UNUSED"],
'0308':["DBYTLO","BYTE COUNT"],
'0309':["DBYTHI","..."],
'030A':["DAUX1","COMMAND AUXILLARY BYTES"],
'030B':["DAUX2","..."],
'030C':["TIMER1","INITIAL TIMER VALUE"],
'030D':["TIMER1+1",""],
'030E':["ADDCOR","ADDITION CORRECTION"],
'030F':["CASFLG","CASSETTE MODE WHEN SET"],
'0310':["TIMER2","FINAL TIME VALUE (USED TO COMPUTE BAUD RATE)"],
'0311':["TIMER2+1",""],
'0312':["TEMP1","TEMP LOCATIONS"],
'0313':["TEMP2",""],
'0314':["TEMP2","..."],
'0315':["TEMP3","..."],
'0316':["SAVIO","SAVE SERIAL IN DATA PORT"],
'0317':["TIMFLG","TIME OUT FLAG FOR BAUD RATE CORRECTION"],
'0318':["STACKP","SIO STACK POINTER SAVE LOC"],
'0319':["TSTAT","TEMP STATUS LOC"],
'031A':["HATABS","HANDLER ADDRESS TABLE"],
'033D':["PUPBT1",""],
'033E':["PUPBT2",""],
'033F':["PUPBT3",""],
'0340':["IOCB0","I/O CONTROL BLOCK 0"],
'0341':["ICDNO","DEVICE NUMBER (DRIVE NUMBER)"],
'0342':["ICCOM","COMMAND CODE"],
'0343':["ICSTA","STATUS"],
'0344':["ICBAL","BUFFER ADDRESS"],
'0345':["ICBAH","..."],
'0346':["ICPTL","PUT BYTE ROUTINE ADDRESS - 1"],
'0347':["ICPTH","..."],
'0348':["ICBLL","BUFFER LENGTH"],
'0349':["ICBLH","..."],
'034A':["ICAX1","AUXILLARY INFO"],
'034B':["ICAX2","..."],
'034C':["ICSPR","4 SPARE BYTES"],
'034D':["B0-ICAX4",""],
'034E':["B0-ICAX5",""],
'034F':["B0-ICAX6",""],
'0350':["IOCB1","I/O CONTROL BLOCK 1"],
'0351':["B1-ICDNO",""],
'0352':["B1-ICCOM",""],
'0353':["B1-ICSTA",""],
'0354':["B1-ICBAL",""],
'0355':["B1-ICBAH",""],
'0356':["B1-ICPTL",""],
'0357':["B1-ICPTH",""],
'0358':["B1-ICBLL",""],
'0359':["B1-ICBLH",""],
'035A':["B1-ICAX1",""],
'035B':["B1-ICAX2",""],
'035C':["B1-ICAX3",""],
'035D':["B1-ICAX4",""],
'035E':["B1-ICAX5",""],
'035F':["B1-ICAX6",""],
'0360':["IOCB2","I/O CONTROL BLOCK 2"],
'0361':["B2-ICDNO",""],
'0362':["B2-ICCOM",""],
'0363':["B2-ICSTA",""],
'0364':["B2-ICBAL",""],
'0365':["B2-ICBAH",""],
'0366':["B2-ICPTL",""],
'0367':["B2-ICPTH",""],
'0368':["B2-ICBLL",""],
'0369':["B2-ICBLH",""],
'036A':["B2-ICAX1",""],
'036B':["B2-ICAX2",""],
'036C':["B2-ICAX3",""],
'036D':["B2-ICAX4",""],
'036E':["B2-ICAX5",""],
'036F':["B2-ICAX6",""],
'0370':["IOCB3","I/O CONTROL BLOCK 3"],
'0371':["B3-ICDNO",""],
'0372':["B3-ICCOM",""],
'0373':["B3-ICSTA",""],
'0374':["B3-ICBAL",""],
'0375':["B3-ICBAH",""],
'0376':["B3-ICPTL",""],
'0377':["B3-ICPTH",""],
'0378':["B3-ICBLL",""],
'0379':["B3-ICBLH",""],
'037A':["B3-ICAX1",""],
'037B':["B3-ICAX2",""],
'037C':["B3-ICAX3",""],
'037D':["B3-ICAX4",""],
'037E':["B3-ICAX5",""],
'037F':["B3-ICAX6",""],
'0380':["IOCB4","I/O CONTROL BLOCK 4"],
'0381':["B4-ICDNO",""],
'0382':["B4-ICCOM",""],
'0383':["B4-ICSTA",""],
'0384':["B4-ICBAL",""],
'0385':["B4-ICBAH",""],
'0386':["B4-ICPTL",""],
'0387':["B4-ICPTH",""],
'0388':["B4-ICBLL",""],
'0389':["B4-ICBLH",""],
'038A':["B4-ICAX1",""],
'038B':["B4-ICAX2",""],
'038C':["B4-ICAX3",""],
'038D':["B4-ICAX4",""],
'038E':["B4-ICAX5",""],
'038F':["B4-ICAX6",""],
'0390':["IOCB5","I/O CONTROL BLOCK 5"],
'0391':["B5-ICDNO",""],
'0392':["B5-ICCOM",""],
'0393':["B5-ICSTA",""],
'0394':["B5-ICBAL",""],
'0395':["B5-ICBAH",""],
'0396':["B5-ICPTL",""],
'0397':["B5-ICPTH",""],
'0398':["B5-ICBLL",""],
'0399':["B5-ICBLH",""],
'039A':["B5-ICAX1",""],
'039B':["B5-ICAX2",""],
'039C':["B5-ICAX3",""],
'039D':["B5-ICAX4",""],
'039E':["B5-ICAX5",""],
'039F':["B5-ICAX6",""],
'03A0':["IOCB6","I/O CONTROL BLOCK 6"],
'03A1':["B6-ICDNO",""],
'03A2':["B6-ICCOM",""],
'03A3':["B6-ICSTA",""],
'03A4':["B6-ICBAL",""],
'03A5':["B6-ICBAH",""],
'03A6':["B6-ICPTL",""],
'03A7':["B6-ICPTH",""],
'03A8':["B6-ICBLL",""],
'03A9':["B6-ICBLH",""],
'03AA':["B6-ICAX1",""],
'03AB':["B6-ICAX2",""],
'03AC':["B6-ICAX3",""],
'03AD':["B6-ICAX4",""],
'03AE':["B6-ICAX5",""],
'03AF':["B6-ICAX6",""],
'03B0':["IOCB7","I/O CONTROL BLOCK 7"],
'03B1':["B7-ICDNO",""],
'03B2':["B7-ICCOM",""],
'03B3':["B7-ICSTA",""],
'03B4':["B7-ICBAL",""],
'03B5':["B7-ICBAH",""],
'03B6':["B7-ICPTL",""],
'03B7':["B7-ICPTH",""],
'03B8':["B7-ICBLL",""],
'03B9':["B7-ICBLH",""],
'03BA':["B7-ICAX1",""],
'03BB':["B7-ICAX2",""],
'03BC':["B7-ICAX3",""],
'03BD':["B7-ICAX4",""],
'03BE':["B7-ICAX5",""],
'03BF':["B7-ICAX6",""],
'03C0':["PRNBUF","PRINTER BUFFER"],
'03E8':["SUPERF",""],
'03E9':["CKEY",""],
'03EA':["CASSBT",""],
'03EB':["CARTCK",""],
'03EC':["DERRF",""],
'03ED':["ACMVAR",""],
'03F8':["BASICF",""],
'03F9':["MINTLK",""],
'03FA':["GINTLK",""],
'03FB':["CHLINK",""],
'03FC':["CHLINK+1",""],
'03FD':["CASBUF","CASSETTE BUFFER"],
'9FFA':["R-CARTCS",""],
'9FFB':["R-CARTCS+1",""],
'9FFC':["R-CART",""],
'9FFD':["R-CARTFG",""],
'9FFE':["R-CARTAD",""],
'9FFF':["R-CARTAD+1",""],
'BFFA':["CARTCS",""],
'BFFB':["CARTCS+1",""],
'BFFC':["CART",""],
'BFFD':["CARTFG",""],
'BFFE':["CARTAD",""],
'BFFF':["CARTAD+1",""],
'D000':["M0PF",""],
'D001':["M1PF",""],
'D002':["M2PF",""],
'D003':["M3PF",""],
'D004':["P0PF",""],
'D005':["P1PF",""],
'D006':["P2PF",""],
'D007':["P3PF",""],
'D008':["M0PL",""],
'D009':["M1PL",""],
'D00A':["M2PL",""],
'D00B':["M3PL",""],
'D00C':["P0PL",""],
'D00D':["P1PL",""],
'D00E':["P2PL",""],
'D00F':["P3PL",""],
'D010':["TRIG0",""],
'D011':["TRIG1",""],
'D012':["TRIG2",""],
'D013':["TRIG3",""],
'D014':["PAL",""],
'D015':["COLPM3",""],
'D016':["COLPF0",""],
'D017':["COLPF1",""],
'D018':["COLPF2",""],
'D019':["COLPF3",""],
'D01A':["COLBK",""],
'D01B':["PRIOR",""],
'D01C':["VDELAY",""],
'D01D':["GRACTL",""],
'D01E':["HITCLR",""],
'D01F':["CONSOL",""],
'D100':["PBI",""],
'D1FF':["PDVI",""],
'D200':["POT0",""],
'D201':["POT1",""],
'D202':["POT2",""],
'D203':["POT3",""],
'D204':["POT4",""],
'D205':["POT5",""],
'D206':["POT6",""],
'D207':["POT7",""],
'D208':["ALLPOT",""],
'D209':["KBCODE",""],
'D20A':["RANDOM",""],
'D20B':["POTGO",""],
'D20D':["SERIN",""],
'D20E':["IRQST",""],
'D20F':["SKSTAT",""],
'D300':["PORTA",""],
'D301':["PORTB",""],
'D302':["PACTL",""],
'D303':["PBCTL",""],
'D400':["DMACTL",""],
'D401':["CHACTL",""],
'D402':["DLISTL",""],
'D403':["DLISTH",""],
'D404':["HSCROL",""],
'D405':["VSCROL",""],
'D407':["PMBASE",""],
'D409':["CHBASE",""],
'D40A':["WSYNC",""],
'D40B':["VCOUNT",""],
'D40C':["PENH",""],
'D40D':["PENV",""],
'D40E':["NMIEN",""],
'D40F':["NMIST",""],
'D600':["PBIRAM",""],
'D800':["AFP",""],
'D803':["PDID1",""],
'D805':["PDIOV",""],
'D806':["PDIOV+1",""],
'D808':["PDIRQV",""],
'D809':["PDIRQV+1",""],
'D80B':["PDID2",""],
'D80D':["PDVV",""],
'D8E6':["FASC",""],
'D9AA':["IFP",""],
'D9D2':["FPI",""],
'DA44':["ZFR0",""],
'DA46':["ZF1",""],
'DA60':["FSUB",""],
'DA66':["FADD",""],
'DADB':["FMUL",""],
'DB28':["FDIV",""],
'DD40':["PLYEVL",""],
'DD89':["FLD0R",""],
'DD8D':["FLD0P",""],
'DD98':["FLD1R",""],
'DD9C':["FLD1P",""],
'DDA7':["FST0R",""],
'DDAB':["FST0P",""],
'DDB6':["FMOVE",""],
'DDC0':["EXP",""],
'DDCC':["EXP10",""],
'DECD':["LOG",""],
'DED1':["LOG10",""],
'E400':["EDITRV","EDITOR"],
'E410':["SCRENV","TELEVISION SCREEN"],
'E420':["KEYBDV","KEYBOARD"],
'E430':["PRINTV","PRINTER"],
'E440':["CASETV","CASSETTE"],
'E450':["DISKIV","DISK INITIALIZATION"],
'E453':["DSKINV","DISK INTERFACE"],
'E456':["CIOV","CIO ROUTINE"],
'E459':["SIOV","SIO ROUTINE"],
'E45C':["SETVBV","SET VERTICAL BLANK VECTORS"],
'E45F':["SYSVBV","SYSTEM VERTICAL BLANK ROUTINE"],
'E462':["XITVBV","EXIT VERTICAL BLANK ROUTINE"],
'E465':["SIOINV","SIO INIT"],
'E468':["SENDEV","SEND ENABLE ROUTINE"],
'E46B':["INTINV","INTERRUPT HANDLER INIT"],
'E46E':["CIOINV","CIO INIT"],
'E471':["BLKBDV","BLACKBOARD MODE"],
'E474':["WARMSV","WARM START ENTRY POINT"],
'E477':["COLDSV","COLD START ENTRY POINT"],
'E47A':["RBLOKV",""],
'E47D':["RBLOKV","CASSETTE READ BLOCK VECTOR"],
'E480':["DSOPIV","CASSETTE OPEN FOR INPUT VECTOR"],
'E483':["SLFTSV",""],
'E486':["PHENTV",""],
'E489':["PHUNLV",""],
'E48C':["PHINIV",""],
'E48F':["GPDVV",""],
'F385':["PUTLIN","OUTPUT LINE TO IOCB#0"],
'F6A4':["EOUTCH","OUTPUT CHAR TO SCREEN"],
'F6E2':["KGETCH","GET CHAR FROM KEYBOARD"]
}

//===================================================================================================
//===================================================================================================
// 6502 disassembler derived from
// n. landsteiner, mass:werk / electronic tradion 2005; e-tradion.net

var opctab= [
    ['BRK','imp'], ['ORA','inx'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ORA','zpg'], ['ASL','zpg'], ['???','imp'],
    ['PHP','imp'], ['ORA','imm'], ['ASL','acc'], ['???','imp'],
    ['???','imp'], ['ORA','abs'], ['ASL','abs'], ['???','imp'],
    ['BPL','rel'], ['ORA','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ORA','zpx'], ['ASL','zpx'], ['???','imp'],
    ['CLC','imp'], ['ORA','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ORA','abx'], ['ASL','abx'], ['???','imp'],
    ['JSR','abs'], ['AND','inx'], ['???','imp'], ['???','imp'],
    ['BIT','zpg'], ['AND','zpg'], ['ROL','zpg'], ['???','imp'],
    ['PLP','imp'], ['AND','imm'], ['ROL','acc'], ['???','imp'],
    ['BIT','abs'], ['AND','abs'], ['ROL','abs'], ['???','imp'],
    ['BMI','rel'], ['AND','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['AND','zpx'], ['ROL','zpx'], ['???','imp'],
    ['SEC','imp'], ['AND','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['AND','abx'], ['ROL','abx'], ['???','imp'],
    ['RTI','imp'], ['EOR','inx'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['EOR','zpg'], ['LSR','zpg'], ['???','imp'],
    ['PHA','imp'], ['EOR','imm'], ['LSR','acc'], ['???','imp'],
    ['JMP','abs'], ['EOR','abs'], ['LSR','abs'], ['???','imp'],
    ['BVC','rel'], ['EOR','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['EOR','zpx'], ['LSR','zpx'], ['???','imp'],
    ['CLI','imp'], ['EOR','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['EOR','abx'], ['LSR','abx'], ['???','imp'],
    ['RTS','imp'], ['ADC','inx'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ADC','zpg'], ['ROR','zpg'], ['???','imp'],
    ['PLA','imp'], ['ADC','imm'], ['ROR','acc'], ['???','imp'],
    ['JMP','ind'], ['ADC','abs'], ['ROR','abs'], ['???','imp'],
    ['BVS','rel'], ['ADC','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ADC','zpx'], ['ROR','zpx'], ['???','imp'],
    ['SEI','imp'], ['ADC','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['ADC','abx'], ['ROR','abx'], ['???','imp'],
    ['???','imp'], ['STA','inx'], ['???','imp'], ['???','imp'],
    ['STY','zpg'], ['STA','zpg'], ['STX','zpg'], ['???','imp'],
    ['DEY','imp'], ['???','imp'], ['TXA','imp'], ['???','imp'],
    ['STY','abs'], ['STA','abs'], ['STX','abs'], ['???','imp'],
    ['BCC','rel'], ['STA','iny'], ['???','imp'], ['???','imp'],
    ['STY','zpx'], ['STA','zpx'], ['STX','zpy'], ['???','imp'],
    ['TYA','imp'], ['STA','aby'], ['TXS','imp'], ['???','imp'],
    ['???','imp'], ['STA','abx'], ['???','imp'], ['???','imp'],
    ['LDY','imm'], ['LDA','inx'], ['LDX','imm'], ['???','imp'],
    ['LDY','zpg'], ['LDA','zpg'], ['LDX','zpg'], ['???','imp'],
    ['TAY','imp'], ['LDA','imm'], ['TAX','imp'], ['???','imp'],
    ['LDY','abs'], ['LDA','abs'], ['LDX','abs'], ['???','imp'],
    ['BCS','rel'], ['LDA','iny'], ['???','imp'], ['???','imp'],
    ['LDY','zpx'], ['LDA','zpx'], ['LDX','zpy'], ['???','imp'],
    ['CLV','imp'], ['LDA','aby'], ['TSX','imp'], ['???','imp'],
    ['LDY','abx'], ['LDA','abx'], ['LDX','aby'], ['???','imp'],
    ['CPY','imm'], ['CMP','inx'], ['???','imp'], ['???','imp'],
    ['CPY','zpg'], ['CMP','zpg'], ['DEC','zpg'], ['???','imp'],
    ['INY','imp'], ['CMP','imm'], ['DEX','imp'], ['???','imp'],
    ['CPY','abs'], ['CMP','abs'], ['DEC','abs'], ['???','imp'],
    ['BNE','rel'], ['CMP','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['CMP','zpx'], ['DEC','zpx'], ['???','imp'],
    ['CLD','imp'], ['CMP','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['CMP','abx'], ['DEC','abx'], ['???','imp'],
    ['CPX','imm'], ['SBC','inx'], ['???','imp'], ['???','imp'],
    ['CPX','zpg'], ['SBC','zpg'], ['INC','zpg'], ['???','imp'],
    ['INX','imp'], ['SBC','imm'], ['NOP','imp'], ['???','imp'],
    ['CPX','abs'], ['SBC','abs'], ['INC','abs'], ['???','imp'],
    ['BEQ','rel'], ['SBC','iny'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['SBC','zpx'], ['INC','zpx'], ['???','imp'],
    ['SED','imp'], ['SBC','aby'], ['???','imp'], ['???','imp'],
    ['???','imp'], ['SBC','abx'], ['INC','abx'], ['???','imp']
];

var addrtab= {
    acc:'A',
    abs:'abs',
    abx:'abs,X',
    aby:'abs,Y',
    imm:'#',
    imp:'impl',
    ind:'ind',
    inx:'X,ind',
    iny:'ind,Y',
    rel:'rel',
    zpg:'zpg',
    zpx:'zpg,X',
    zpy:'zpg,Y'
}

var steptab = {
    imp:1,
    acc:1,
    imm:2,
    abs:3,
    abx:3,
    aby:3,
    zpg:2,
    zpx:2,
    zpy:2,
    ind:3,
    inx:2,
    iny:2,
    rel:2
};

// functions
function disassembleStep(pc,ram,asm,flags)
{
    var instr, op1, op2, addr, ops, disas, adm, step;
    var symbol;

    // get instruction and ops, inc pc
    function u8(i) {
        return ram[i];
    }
    instr=u8(pc);
    addr=hex(pc,4);
    ops=hex(instr);
    disas=opctab[instr][0];
    adm=opctab[instr][1];
    step=steptab[adm];
    if (step>1) {
        op1=hex(u8(pc+1));
        if (step>2) op2=hex(u8(pc+2));
    }

    // format and output to listing
    switch (adm) {
        case 'imm' :
            ops+=' '+op1+'   ';
            disas+=' #$'+op1;
            break;
        case 'zpg' :
            ops+=' '+op1+'   ';
            disas+=' $'+op1;
            break;
        case 'acc' :
            ops+='      ';
            disas+=' A';
            break;
        case 'abs' :
            ops+=' '+op1+' '+op2;
            disas+=' $'+op2+op1;
            break;
        case 'zpx' :
            ops+=' '+op1+'   ';
            disas+=' $'+op1+',X';
            break;
        case 'zpy' :
            ops+=' '+op1+'   ';
            disas+=' $'+op1+',Y';
            break;
        case 'abx' :
            ops+=' '+op1+' '+op2;
            disas+=' $'+op2+op1+',X';
            break;
        case 'aby' :
            ops+=' '+op1+' '+op2;
            disas+=' $'+op2+op1+',Y';
            break;
        case 'iny' :
            ops+=' '+op1+'   ';
            disas+=' ($'+op1+'),Y';
            break;
        case 'inx' :
            ops+=' '+op1+'   ';
            disas+=' ($'+op1+',X)';
            break;
        case 'rel' :
            var opv=u8(pc+1);
            var targ=pc+2;
            if (opv&128) {
                targ-=(opv^255)+1;
            }
            else {
                targ +=opv;
            }
            targ&=0xffff;
            ops+=' '+op1+'   ';
            disas+=' $'+hex(targ,4);
            break;
        case 'ind' :
            ops+=' '+op1+' '+op2;
            disas+=' ($'+op2+op1+')';
            break;
        default :
            ops+='      ';
    }

    // add symbols
    switch (adm) {
        case 'zpg' :
        case 'zpx' :
        case 'zpy' :
        case 'inx' :
        case 'iny' :
            symbol = _syms_zp[op1];
            break;

        case 'abs' :
        case 'abx' :
        case 'aby' :
        case 'ind' :
            if (op2 == '00')
                symbol = _syms_zp[op1];
            else
                symbol = _syms_[op2+op1];
            break;
    }        
    if (ops=='')
        ops='        ';

    // mark validty, enrty and exit points
    // 1 = valid
    // 8 = end of block
    // 0x80 = start of block
    var valid = instr && disas != '???';
    if (valid) {
        for (var i = 0; i < step; i++)
            flags[i+pc] |= 1;    // valid code
        var a = ram[pc+1] + (ram[pc+2] << 8);
        switch (instr) {
            case 0x20: flags[a] |= 0x80; break; // jsr
            case 0x4C: flags[a] |= 0x80; flags[pc] |= 0x48; break; // jmp
            case 0x40: flags[pc] |= 0x28; break; // rti
            case 0x60: flags[pc] |= 0x18; break; // rts
        }
        if (adm == 'rel')
            flags[targ] |= 0x80;
    }

    asm.push({pc:pc,step:step,valid:valid,
        s:addr+'   '+ops+'   '+disas + (symbol ? " ; " + symbol[0] + " <i>" +  symbol[1] + "</i>": "")});
    return (pc+step)&0xffff;
}

//  First disassembly pass
function disassemble(addr,data,i,len,ram,flags)
{
    var asm = [];
    for (var j = 0; j < len; j++)
        ram[addr+j] = data[i+j];
    var pc = addr;
    while (pc < (addr+len))
        pc = disassembleStep(pc,ram,asm,flags);
    return asm;
}

// Two pass: disassembly then basic blocks
function disassemble2(asm,str,ram,flags)
{
    var start = 0xFFFF;
    var end = 0;
    asm.forEach(a => {
        a.flags = flags[a.pc];
        start = Math.min(start,a.pc);
        end = Math.max(end,a.pc,a.step);
        //a.s = hex(a.flags) + ":" + a.s;
    });

    function separator()
    {
        if (str[str.length-1] == "")
            return;
        str.push("");
    }

    function end_of_lines(lines)
    {
        return lines[lines.length-1].pc + lines[lines.length-1].step;
    }
    function runny(lines)
    {
        var start = lines[0].pc;
        var end = end_of_lines(lines);
        if ((end-start) < 2)
            return;
        for (var i = start+1; i < end; i++)
            if (ram[start] != ram[i])
                return false;
        return true;    // All data is the same value
    }

    function as_data(blocks)
    {
        var from = blocks[0].lines[0].pc;
        var to = end_of_lines(blocks[blocks.length-1].lines);

        var key = hex(from,4);
        str.push(`; Data ${key} to ${hex(to-1,4)} (${to-from} bytes)<em class='showcode' onclick='toggle("#_${key}")'>Show As Code</em>`);
        //  stick all the code in too
        str.push(`<div id='_${key}' style='color:#F00;display:none'>`);
        blocks.forEach(block => block.lines.forEach(line => str.push(line.s)));
        str.push("</div>");

        while (from < to) {
            var mx = 16 - (from & 0xF);
            var n = Math.min(mx,to-from);
            str.push(hex_line(from,ram,from,n,4));
            from += n;
        }
        separator();
    }

    // slice into blocks, mark those
    var blocks = [];
    var block = {lines:[],errs:0};
    function flush_block()
    {
        if (block.lines.length)
            blocks.push(block);
        block = {lines:[],errs:0};
    }
    asm.forEach(a => {
        if (a.flags & 0x80)
            flush_block();
        block.lines.push(a);
        if (!a.valid)
            block.errs++;
        if ((a.flags & 0x08) && block.errs == 0)
            flush_block();
    });
    flush_block();

    // determine if each block is ASM or DATA
    var first_code = true;
    separator();
    var data = [];
    blocks.forEach(block => {
        if (block.errs || runny(block.lines)) {
            data.push(block);           // start of data
        } else {
            if (data.length) {
                as_data(data);    // end of data
                data = [];
            }
            if (first_code) {
                str.push("; Disassembly of " + hex(start,4) + " to " + hex(end-1,4));
                first_code = false;
            }
            block.lines.forEach(a => str.push(a.s));
        }
        separator();
    });
    if (data.length)
        as_data(data);
    separator();
}

// eof

//===================================================================================================
//===================================================================================================

function le16(a,i)
{
	return a[i] | ((a[i+1]) << 8);
}

function le32(a,i)
{
    return a[i] | ((a[i+1]) << 8) | ((a[i+2]) << 16) | ((a[i+3]) << 24);
}

function is_zero(d,i,len)
{
    while (len--)
        if (d[i++])
            return false;
    return true;
}

function toAscii(a,i,len)
{
	var s = '';
	while (len--)
		s += String.fromCharCode(a[i++]);
	return s;
}

function err(e)
{
	_m("#err","#toc",{err:e});
}

function ataritext(a)
{
	var s = '';
    var lst = [];
	for (var i = 0; i < a.length; i++) {
		if (a[i] == 0x9B) {
            lst.push(s);
            s = '';
		} else
			s += String.fromCharCode(a[i]);
	}
    if (s.length)
        lst.push(s);
	return lst;
}

function parse_failed(f)
{
    return [`Can't parse ${f.name} as a ${f.ext} file`]; //'
}

function show_m65(f)
{
    var asm = mac65(f.data,0,f.data.length);
    // expand tabs?
    show_ataritext(f,asm ? asm : parse_failed(f));
}

function show_bas(f)
{
    var t = ataribasic(f.data,0,f.data.length);
    show_ataritext(f,t ? t.listing: parse_failed(f));
}

function show_txt(f)
{
    var t = ataritext(f.data,0,f.data.length);
    show_ataritext(f,t);
}

// 160*192 2 bit + [4 byte palette]
function show_img(f)
{
    render_file(f);
    var c = _q("#show");
    var aspect = render_image(c,f);
    resize_parent(c,aspect[0],aspect[1]);
}

// https://github.com/TheRobotFactory/EightBit-Atari-Fonts
function show_fnt(f)
{
    var pal = _reload_palette ? [0,5,10,15] : _palette.slice();
    var multicolor = _checks['multicolor'];

    function fnt(n,len) {
        var space = (n & 0x80) ? String.fromCharCode(128+32) : ' ';
        var s = space;
        for (var i = 0; i < len; i++)
            s += String.fromCharCode(n+i);
        return s + space;
    }
    var inverted = '';
    for (var i = 0; i < 34; i++)
        inverted += String.fromCharCode(32+128);

    var t = [];
    t.push("");
    t.push(fnt(32,32)); t.push("");
    t.push(fnt(64,32)); t.push("");
    t.push(fnt(0,32)); t.push("");
    t.push(fnt(96,32)); t.push("");
    t.push(inverted);
    t.push(fnt(32+128,32)); t.push(inverted);
    t.push(fnt(64+128,32)); t.push(inverted);
    t.push(fnt(0+128,32)); t.push(inverted);
    t.push(fnt(96+128,32)); t.push(inverted);
    var s = [
        "",
        "YOU ARE IN A MAZE OF TWISTY",
        "LITTLE PASSAGES, ALL ALIKE.",
        "",
        " - Crowther & Woods",
        "",
        "",
        "Never argue with an idiot.",
        "They will drag you down to their",
        "level and beat you with",
        "experience.",
        "",
        " - Mark Twain",
        "",
        "",
        "Nobody ever figures out what",
        "life is all about, and it doesn't",
        "matter. Explore the world. Nearly",
        "everything is really interesting",
        "if you go into it deeply enough.",
        "",
        " - Richard P. Feynman",
        "",
    ];
    s.forEach(line => t.push(' ' + line));
    t.push("");

    show_ataritext(f,t,f.data,multicolor?_palette:null);
}

var _exts = {
    "atr": {name:"ATR Disk Image"},
    "dat": {name:"Raw Data"},

    "--0": {name:"Languages"},
    "bas": {name:"Atari Basic/Turbo Basic XL", is_txt:true },
    "lst": {name:"Atari Basic Listing", is_txt:true },
    "asm": {name:"Assembly Listing", is_txt:true },
    "m65": {name:"MAC/65 Assembly Listing", is_txt:true },
    "lis": {name:"Listing", is_txt:true },
    "doc": {name:"Document", is_txt:true },
    "ata": {name:"ATASCII Text File", is_txt:true },
    "txt": {name:"Text File", is_txt:true },

    "--1": {name:"Graphics"},
    "fnt": {name:"Font File", is_txt:true, font_set:true },
    //"set": {name:"Font File", is_txt:true font_set:true },

    "gr7": {name:"Graphics 7 Image", is_img:true },
    "gr8": {name:"Graphics 8 Image", is_img:true },
    "gr9": {name:"Graphics 9 Image", is_img:true },
    "g10": {name:"Graphics 10 Image", is_img:true },

    "mic": {name:"Micropainter Image", is_img:true },
    "mcp": {name:"McPainter/Paradox Image", is_img:true },
    "apc": {name:"APAC 256 Color Image", is_img:true },
    "plm": {name:"Plasma 256 Color Image", is_img:true },
    "pzm": {name:"Pryzm Artist Image", is_img:true },
    "ilc": {name:"Digi Paint Image", is_img:true },
    "inp": {name:"InterPainter Image", is_img:true },
    "cin": {name:"Champions' Interlace", is_img:true },
    "pic": {name:"Koala MicroIllustrator", is_img:true },
    "raw": {name:"XL-Paint MAX Image", is_img:true },
    "scr": {name:"Atari Graphics Works Image", is_img:true },
    "ist": {name:"Interlace Studio Image", is_img:true },
    "rip": {name:"Rocky Interlace Picture", is_img:true },
    "hip": {name:"Hard Interlace Picture", is_img:true },
    "tip": {name:"Taquart Interlace Picture", is_img:true },

    "--2": {name:"Executables"},
    "sys": {name:"System", is_code:true },
    "xex": {name:"Load and Go Executable", is_code:true, header:true },
    "exe": {name:"Load and Go Executable (exe)", is_code:true, header:true },
    "com": {name:"Load and Go Executable (com)", is_code:true, header:true },
    "rom": {name:"ROM Dump File", is_code:true },
    "car": {name:"Cartridge File", is_code:true },
    "obj": {name:"Object Code", is_code:true },
};

// guss the file type
function get_ext(name,a)
{
    var i = name.lastIndexOf(".");
    if (i != -1) {
        var ext = name.substr(i+1).toLowerCase();
        if (_exts[ext])
            return ext;
    }

    var sig = le16(a,0);
    if (sig == 0x296)
        return "atr";

    if (sig == 0xFFFF && (le16(a,2) < le16(a,4)))
        return "xex";

    if (sig == 0x80FF && le16(a,2) == 0xC7C9)
        return "pic";

    if (sig == 0x4952)
        return "rip";

    if (sig == 0xFEFE)
        return "m65";

    if (ataribasic(a,0,a.length))
        return "bas";

    var s='';
    for (var i = 0; i < a.length; i++)
        s += String.fromCharCode(a[i]);
    if ((s.indexOf("REM") != -1) || (s.indexOf("GOTO") != -1) || (s.indexOf("THEN") != -1))
        return "lst";

    return "dat";
}

var _id = 1;
var _container_id = 1;
var _containers = [];
function get_file(id)
{
    var f;
    _containers.forEach(c => c.files.forEach(i => { if(i.id == id) f = i}));
    return f;
}

var _shown;
function save(as_lst)
{
    var f = _shown;
    if (as_lst && f.ext == "bas")
    {
        var b = ataribasic(f.data,0,f.data.length);
        var n = f.name;
        if (n.substr(n.length-4).toLowerCase() == ".bas")
            n = n.substr(0,n.length-4);     // trim ".BAS"
        save_bytes(n+".LST",b.lst);
    } else
        save_bytes(f.name,f.data);
}

function xex_dump(name,a,i,len,expect_header,org,entry)
{
    if (name == "DOS.SYS")
        org = 0x07CB;   // http://data.atariwiki.org/DOC/Inside_Atari_DOS_GBXL.pdf

    var flags = new Uint8Array(0x10000);
    var ram = new Uint8Array(0x10000);
    var entry_points = [];
    if (entry) {
        flags[entry] = 0x80;
        entry_points.push(entry);
    }

    var header = le16(a,i) == 0xFFFF;   // 
    var lines = [];
    if (!header)
    {
        org = org || 0x700;
        var sig = le32(a,i);
        if (sig == 0x54524143) // 'CART'
        {
            org = 0x8000;
            i += 16;        // Cart file
            len -= 16;
        }

        lines.push("; file " + name + " is " + len + " bytes");
        if (entry != org)
            entry_points.unshift(org);
        entry_points.push(org+len);
        var asms = [];
        for (var j = 0; j < entry_points.length-1; j++) {  // try and get good starting points on entry
            var ep = entry_points[j];
            var ln = entry_points[j+1]-ep;
            asms.push(disassemble(ep,a,i,ln,ram,flags));
            i += ln;
        }
        asms.forEach(asm => disassemble2(asm,lines,ram,flags));
    } else {
        lines.push("; file " + name + " is " + len + " bytes");
        var segs = [];
        var e = len+i;
        var s;

        // walk segments, collect entry points
        // draw them all at head, repeat them in body
        while (i < e) {
            var start = 0xFFFF;
            var end = 0xFFFF;
            var addr = 0xFFFF;
            while (start == 0xFFFF) {
                start = le16(a,i);
                i += 2;
            }
            end = le16(a,i);
            var slen = end+1 - start;
            i += 2;
            if ((slen < 0) || (i + slen > e)) {
                lines.push("; invalid xex segment ");
                break;
            }
            s = "; code segment " + slen + " bytes at " + hex(start,4) + ":" +  hex(end,4);

            var seg = {start:start,end:end,offset:i};
            if ((slen == 2) && (start == 0x2E0 || start == 0x2E2)) {
                seg.addr = le16(a,i);
                entry_points.push(seg.addr);
                flags[seg.addr] = 0x80;
                s += " -> " + (start == 0x2E0 ? "run":"initialize") + " at " + hex(seg.addr,4);
            }
            lines.push(s);
            segs.push(seg);
            i += slen;
        }
        lines.push("");

        // Do the disassembly
        var asms = {};
        segs.forEach(seg => {
            if (!seg.addr)
                asms[seg.offset] = disassemble(seg.start,a,seg.offset,seg.end+1 - seg.start,ram,flags);  // disassemble segment
        });

        // Do the disassembly
        segs.forEach(seg => {
            lines.push("; ===================================================");
            var slen = seg.end+1 - seg.start;
            s = "; code segment " + slen + " bytes at " + hex(seg.start,4) + ":" +  hex(seg.end,4);
            if (seg.addr)
                s += " -> " + (seg.start == 0x2E0 ? "run":"initialize") + " at " + hex(seg.addr,4);
            lines.push(s);
            lines.push('');
            if (asms[seg.offset])
                disassemble2(asms[seg.offset],lines,ram,flags);
        });
    }
    return lines.join("\n");
}


// http://atari.kensclassics.org/dos.htm
// http://www.atarimax.com/jindroush.atari.org/afmtatr.html
class ATR {
    constructor(d,name) {
        this.d = d;
        this.name = name;
        this.size = (le16(d,2) << 4) + (d[6] << 16);
        this.sector_size = le16(d,4);
        this.sector_count = (this.size-128*3)/this.sector_size + 3;
    }

    sector_offset(n) {    // 1 based
        n--;
        if (n < 3)
            return 16 + n*0x80;     // header is 16 bytes
        return 16 + 3*0x80 + (n-3)*this.sector_size;
    }

    one_dir(n) {
        var d = this.d;
        var j = this.sector_offset(361 + (n >> 3)) + (n & 7)*16;
        var dir = {
            flags:d[j],
            total:le16(d,j+1),
            start:le16(d,j+3),
            name83:toAscii(d,j+5,11),
            name:toAscii(d,j+5,8).trim() + '.' + toAscii(d,j+13,3)
        };
        dir.valid = !is_zero(d,j,16) && (dir.total < this.sector_count) && (dir.start < this.sector_count) && (dir.flags & 0x40);
        return dir;
    }

    get_dir() {
        var dir = [];
        var valid = false;
        for (var n = 0; n < 64; n++)
        {
            dir[n] = this.one_dir(n);
            valid = valid || (n < 8 && dir[n].valid);  // look for sneaky directory entries
        }
        if (!valid) {                                  // no valid entries in first dir sector
            for (var n = 0; n < 8; n++)                // see if they are hiding in 369
                dir[n] = this.one_dir(n+64);           // from Cribbage etc
        }
        for (var n = 0; n < 64; n++)
            dir[n].number = n;
        return dir;
    }

    read(f) {
        var data = [];
        var count = f.total;
        var sector = f.start;
        var d = this.d;
        f.errors = 0;
        while (count--) {
            var i = this.sector_offset(sector);
            var end = i + this.sector_size;
            var len = d[end-1];
            if (len > 125)
                f.errors++;
            var num = d[end-3] >> 2;
            var next = ((d[end-3] & 0x3) << 8) | d[end-2];
            if (num != f.number)
                f.errors++;
            for (var k = 0; k < len; k++)
                data.push(d[i + k]);
            if (next == 0) {
                if (count)
                    f.errors++;
                break;  // EOF?
            }
            sector = next;
        }
        return new Uint8Array(data);
    }
}

// dump atr raw data
function show_atr(f)
{
    var atr = f.atr;
    var d = atr.d;
    var txt = [];

    function pad_hex(n)
    {
        return n > 0xFF ? hex(n,4) : '  ' + hex(n);
    }

    var _br = {
        BFLG:   d[16],          // Boot flag; always equals 0.
        BRCNT:  d[17],          // Number of sectors in the disk boot;
        BLDADDR:le16(d,18),     // Boot load address; where DOS is loaded into memory;  $700
        BINTAD: le16(d,20),     // DOS initialization address;  $1540. 
        BCONT:  le16(d,23),     // skip 4C jmp
        SABYTE: d[25],          // Maximum number of concurrently open files--usually three.
        DRVBYT: d[26],          // Drive allocation byte; one bit per drive.
        SAFBFW: d[27],
        SASA:   le16(d,28),     // Buffer allocation address for drives and files.
        DFSFLG: d[30],          // Reads zero if there is no DOS.SYS on disk, nonzero if present
        DFLINK: le16(d,31),     // Points to first sector of the DOS.SYS file.
        BLDISP: d[33],          // Number of displacement bytes to sector link bytes (last three) = 125
        DFLADDR: le16(d,34),    // Address of the FMS (D:) handler table; $7CB
        // $714 boot continues here...
    };

    function available(n)
    {
        return d[vtoc + 10 + (n >> 3)] & (0x80 >> (n & 3));
    }

    // Check validity of TOC
    var sc = (atr.size - 3*128)/atr.sector_size + 3;
    var vtoc = atr.sector_offset(360);
    var valid = d[vtoc] == 2;
    var total = le16(d,vtoc+1);
    var unused = le16(d,vtoc+3);
    var density;

    if (total > sc || total == 0 || unused > sc)
        valid = false;

    var vtoc2 = 0;
    if (sc <= 720) {
        density = atr.sector_size == 128 ? "Single Density" : "Double Density";
        for (var i = 101; i < 128; i++)
            valid = valid && d[vtoc+i] == 0;
    } else {
        density = "1050 Double (Enhanced) Density";
        vtoc2 = atr.sector_offset(1024);
        if (valid)
            unused += le16(d,vtoc2+122);
    }

    txt.push(`; Image has ${sc} ${atr.sector_size} byte sectors - ` + density);
    txt.push(valid ? `; ${unused} sectors free of ${total} total available` : `; VTOC is invalid`);
    txt.push("; Jump to <a id='BOOT' href='#VTOC'>VTOC</a>");
    if (vtoc2)
        txt.push("; Jump to <a id='BOOT' href='#VTOC2'>VTOC2</a>");
    txt.push("; Jump to <a href='#DIR'>Directory</a>");
    txt.push("");

    // Show boot sectors, disassemble them
    txt.push("; boot record");
    var k = Object.keys(_br);
    for (var i = 0; i < k.length; i++)
        txt.push("; " + pad_hex(_br[k[i]]) + " " + k[i]);
    txt.push("");
    var size = atr.sector_offset(_br.BRCNT+1);    // 0 based
    var boot = d.slice(16,size);
    var cont = _br.BCONT - _br.BLDADDR;
    cont = (cont < 0 || cont >= boot.length) ? _br.BLDADDR : _br.BCONT;
    txt.push(xex_dump("boot",boot,0,boot.length,0,_br.BLDADDR,cont));

    // Scan files/sectors
    // TODO: Broken links, deleted files
    var dirs = atr.get_dir(i);
    var sectors = [];
    for (var i = 0; i < 64; i++) {
        var dir = dirs[i];
        if (dir.valid) {
            var sector = dir.start;
            for (var k = 0; k < dir.total; k++) {
                var end = atr.sector_offset(sector) + atr.sector_size;
                var len = d[end-1];
                var num = d[end-3] >> 2;
                var next = ((d[end-3] & 0x3) << 8) | (d[end-2]);
                sectors[sector] = {len:len,num:num,next:next,offset:k};
                if (next == 0)
                    break;  // EOF?
                sector = next;
            }
        }
    }

    var n = 0;
    for (;;)
    {
        var size = n < 3 ? 128 : atr.sector_size;
        var offset = atr.sector_offset(n+1);
        if (offset >= (atr.size+16))
            break;
        var zero = is_zero(d,offset,size);

        switch (++n) {
            case 360: txt.push("; <span id='VTOC'>Volume Table of Contents <a href='#BOOT'>(back)</a></span>"); break;
            case 361: txt.push("; <span id='DIR'>Directory <a href='#BOOT'>(back)</a></span>"); break;
            case 1024: txt.push("; <span id='VTOC2'>Volume Table of Contents 2<a href='#BOOT'>(back)</a></span>"); break;
        }

        var s = sectors[n];
        var sstr = '';
        if (s) {
            var dir = dirs[s.num];
            if (dir)
                sstr = ` (${dir.name} ${s.offset} of ${dir.total})`;
        }
        txt.push("; Sector " + n + (zero ? " (" + size + " zeros)":"") + sstr);

        if (!zero)
            txt.push(hex_dump(d,offset,size,4));
        txt.push("");

        if (n == _br.BRCNT) {
            txt.push("; ===================================================");
            txt.push("; End of boot sectors");
            txt.push("");
        }
    }

    render_file(f);
    _h("#show",txt.join("\n"));
}

function show(id)
{
    try {
            	var f = get_file(id);
        if (f.data.length == 0)
            return;

        _shown = f;
        if (f.ext == "atr") {
            show_atr(f);
            return;
        }
        if (f.ext == "bas") {
            show_bas(f);
            return;
        }

        if (f.ext == "m65") {
            show_m65(f);
            return;
        }

        if (f.ext == "fnt" || f.ext == "set") {
            show_fnt(f);
            return;
        }

        var e = _exts[f.ext];
        if (e && e.is_img) {
            show_img(f);
            return;
        }

        if (e && e.is_txt) {
            show_txt(f);
            return;
        }

        render_file(f);
        if (e && e.is_code) {
            _h("#show",xex_dump(f.name,f.data,0,f.data.length,e.header));
            return;
        }
        _h("#show",hex_dump(f.data,0,f.data.length));
    }
    catch (err) {
        console.log(err);
        show_as("dat");
    }
}

function show_as(e)
{
    if (_shown) {
        if (!_shown.original_ext)
            _shown.original_ext = _shown.ext;
        _shown.ext = e;
        refresh();    // select one
    }
}

function toggle_hex()
{
    if (!_shown) return;
    if (_shown.ext == "hex")
        show_as(_shown.original_ext);
    else
        show_as("hex");
}

function refresh()
{
    show(_shown.id);
}

function close_container(id)
{
    for (var i = 0; i < _containers.length; i++) {
        if (_containers[i].id == id) {
            _containers.splice(i,1);
            break;
        }
    }
    render_state(_containers);
}

function load_data(name,a)
{
    var ext = get_ext(name,a);
	if (ext != "atr") {        // not an atr file
        var f = {name:name,ext:ext,data:a,id:_id++,total:(a.length+127)>>7};
        var i = name.lastIndexOf(".");
        var ext83 = ext;
        if (i != -1) {
            ext83 = name.substr(i+1);
            name = name.substr(0,i);
        }
        f.name83 = name.substr(0,8);
        while (f.name83.length < 8)
            f.name83 += ' ';
        f.name83 += ext83.toUpperCase().substr(0,3);
        _containers.unshift({name:f.name,ext:ext,data:a,files:[f],id:_container_id++});         // single file
	} else {
        var atr = new ATR(a,name);
        var dir = atr.get_dir();
        var files = [];
        dir.forEach(f => {
            if (f.valid) {
                var file = {name:f.name,name83:f.name83,id:_id++};
                file.data = atr.read(f);
                if (f.errors) {
                    console.log("Error reading file " + f.name);
                    console.log(f);
                } else {
                    file.ext = get_ext(file.name,file.data);
                    files.push(file);
                }
            }
        });
        if (files.length)
            files.push({name83:"",name:name,ext:"",data:[],id:_id++});  // spacer
        files.push({name83:atr.sector_count + " sectors",name:name,ext:"atr",data:a,id:_id++,atr:atr});
        _containers.unshift({name:name,length:a.length,data:a,ext:"atr",files:files,id:_container_id++});
    }
}

//===================================================================================================
//===================================================================================================
// https://www.atarimagazines.com/software/software.html

function load()
{
    drop_init(_q("#toc"),
        (file,ab) => {
            load_data(file.name,new Uint8Array(ab))
        },
        () => {
            render_state(_containers);
            show(_containers[0].files[0].id);    // select one
        }
    );
    _fcanvas = get_font(_font);
    document.body.onkeydown = function (e) {
        switch (e.key) {
            case 'o':
            case 'O':
                _q("#fe").click();
                break;  // open a file....
            case 'h':
            case 'H':
                toggle_hex();
                break;  // toggle hex display
        }
    };
    render_state(_containers);
}

function toggle(eid)
{
    var e = _q(eid);
    e.style.display = e.style.display == "none" ? "block" : "none";
}

function ext_option(f)
{
    var s = `<div style='display:inline-block'><select onchange="show_as(this.value)">`;
    Object.keys(_exts).forEach(ext => s += `<option ${ext[0] == '-' ? "disabled":""} value='${ext}' ${ext == f.ext ? 'selected':''}>${_exts[ext].name}</option>`);
    s += `</select></div>`;
    return s;
}

function finfo(f)
{
    var t = _exts[f.ext] ? _exts[f.ext].name : "'" + f.ext + "' file";
    return `<b>${f.name}</b><div style="font-size:small">${t} (${f.data.length} bytes)</div>`;
}

function redraw_palette()
{
    _h(".palette",palette(_palette));
}

function pick_click(c,i)
{
    _palette[c] = i;
    _reload_palette = 0;    // make sure our changes take
    refresh();
    redraw_palette();
    _reload_palette = 1;
}

function palette(colors)
{
    var atari2css = (i) => '#'+hex(atari_palette_rgb[i],6);
    function atari256(c) {
        var s = [];
        for (var i = 0; i < 256; i++)
            s.push(`<div class='acolor' onclick='pick_click(${c},${i})' style='background:${atari2css(i)}'></div>`);
        return s.join("");
    }
    var s = [];
    for (var c = 0; c < colors.length; c++) {
        s.push(
            `<div class='dropdown'>
                <div class='acolor' style='background:${atari2css(colors[c])}'>
                    <div class='dropdown-content'>${atari256(c)}</div>
                </div>
            </div>`
        );
    }
    return s.join("");
}

function render_state(m)
{
    var h;
    if (m.length == 0) {
        h = `<div style="text-align:center;color:#AAA"><h2>Drag Files Here</h2><h2>or</h2></div>`;
        _h("#tabs","");
        _shown = null;
    } else
        h = m.map(container => 
        `<div>
            <span class='close-icon' onclick="close_container(${container.id})"></span>
            <div class='infof'>${finfo(container)}</div>
            <ul id="menu">
            ${container.files.map(file => 
                `<li onclick="show(${file.id})">
                    <div><canvas id="canvas${file.id}"></canvas></div>
                </li>`
            ).join("")}
            </ul>
        </div>`
    ).join("");
    _h("#menu_container",h);

    function info(f)
    {
        var s = '';
        if (f.total) {
            s = '' + f.total;
            while (s.length < 3)
                s = '0' + s;
        }
        while (s.length < 4)
            s = ' ' + s;
        var n = f.name83;
        while (n.length < 12)
            n += ' ';
        var locked = f.flags & 0x20 ? "*" : " ";
        return "  " + locked + " " + n + s + "  ";
    }

    m.forEach(container => {
        container.files.forEach(file => draw_line(`#canvas${file.id}`,info(file)));
    });

    // show supported file types
    if (m.length == 0) {
        var s = `<div class='exts'>`;
        Object.keys(_exts).forEach(ext => s += ext[0] == '-' ?
            `<div><b></b><strong>${_exts[ext].name}</strong><div>` :
            `<div><b>${ext}</b>${_exts[ext].name}<div>`
        );
        s += `</div>`;
        _h('#tabs',s);
    }
}

function render_file(f)
{
    var txt = _exts[f.ext] ? _exts[f.ext].is_txt : false;
    var img = _exts[f.ext] ? _exts[f.ext].is_img : false;
    var controls = `<div class='radio'>`;
    var buttons = '';

    if (txt) {
        controls += `
            ${f.ext == 'bas' ? check_init('indent','Indent') : ""}
            ${f.ext == 'fnt' ? check_init('multicolor','Multicolor') : ""}
            ${radio_init('layout',['38','40','80','Wide'])}`;
        buttons += `<button onclick="save(1)">Save As LST</button>`;
    }
    if ((f.ext == 'fnt') || (img && is_palettable(f.ext)))
        controls += `<div class="palette" style="display:inline-block">${palette(_palette)}</div>`;

    buttons += `<button onclick="save(0)">Download</button>`;
    controls += `</div>`;

    _h("#tabs",
        `<div class='info'>
            <div style='overflow: auto'>
                <b>${f.name}</b><div style='display:inline-block;float:right'>${buttons}</div>
            </div>
            <div style="font-size:small">
                ${ext_option(f)} ${f.data.length} bytes
                <div style='display:inline-block;float:right'>${controls}</div>
            </div>
        </div>
        <div id="file">${(txt || img) ? `<div><canvas id="show"></canvas></div>` : `<pre style="padding:8px" id="show">eh?</pre>`}</div>`
    );
}

</script>
<body>
<header>
<h2>ATR Image Explorer</h2>
<br />
</header>
<div style="display:flex;flex-direction:row">

<nav style="min-width:352px; max-width:352px; margin-right:8px;" id="toc">
<div id="menu_container" ></div>
<p style="text-align:center;color:#AAA;font-weight:300">
    <span class='open' onclick='_q("#fe").click()'>Open</span><br/>
    <a href="https://github.com/rossumur/esp_8_bit">https://github.com/rossumur/esp_8_bit</a>
</p>
<input type="file" id="fe" multiple style="display:none">
</nav>

<main style="border:solid 1px #CCC">
    <div id="tabs"></div>
</main>
</div>
<script>load()</script>
</body>
</html>
